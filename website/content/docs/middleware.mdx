---
title: "Middleware Guide"
description: "Complete guide to using middleware in BunServe for request processing, authentication, logging, CORS, rate limiting, and more."
---
# Middleware Guide

Complete guide to using middleware in BunServe for request processing, authentication, logging, and more.

## What is Middleware?

Middleware functions run before (and after) your route handlers, allowing you to:
- Log requests
- Authenticate users
- Handle errors
- Add CORS headers
- Parse request bodies
- Measure performance
- And much more!

## Basic Middleware

### Creating Middleware

Middleware functions receive a `context` object (which contains `request`, `params`, `set`, etc.) and a `next` function. You can destructure the context to access only what you need:

```typescript
import { bunserve } from 'bunserve';

const app = bunserve();

// Simple logging middleware that runs before route handlers
// The first parameter is the context object - here we destructure `request` from it
app.use(async ({ request }, next) => {
  console.log(`${request.method} ${request.url}`);
  // Continue to next middleware or handler
  await next();
});

// You can also use the full context object without destructuring
app.use(async (context, next) => {
  console.log(`${context.request.method} ${context.request.url}`);
  await next();
});

// Route handler - runs after middleware
app.get('/', () => 'Hello World');
```

### Middleware Order

Middleware executes in the order you register it:

```typescript
// First middleware - executes first
app.use(async ({}, next) => {
  console.log('1: Before');
  await next(); // Call next middleware
  console.log('1: After');
});

// Second middleware - executes second
app.use(async ({}, next) => {
  console.log('2: Before');
  await next(); // Call route handler
  console.log('2: After');
});

// Route handler - executes last
app.get('/', () => {
  console.log('Handler');
  return 'Done';
});

// Output demonstrates middleware execution order:
// 1: Before
// 2: Before
// Handler
// 2: After
// 1: After
```

## Built-in Middleware

BunServe includes several production-ready middleware:

### Error Handler

Catches and formats errors thrown from route handlers:

```typescript
import { bunserve, error_handler } from 'bunserve';

const app = bunserve();

// Add error handler FIRST to catch all errors thrown in routes
app.use(error_handler());

// Route that throws errors with status property
// The context parameter is destructured to { params }
app.get('/user/:id', ({ params }) => {
  const user = users.find(u => u.id === params.id);

  if (!user) {
    // Throw a plain Error with a status property
    const error: any = new Error('User not found');
    error.status = 404;
    throw error;
  }

  return user;
});

// Errors are automatically caught and formatted:
// {
//   "error": "User not found",
//   "status": 404
// }
```

#### Error Handler Options

```typescript
// Configure error handler with custom options
app.use(error_handler({
  // Include stack traces (default: true in dev, false in production)
  include_stack: true,

  // Custom error formatter function
  format_error: (error, context) => {
    return {
      message: error.message,
      timestamp: new Date().toISOString()
    };
  },

  // Custom error logger function
  log_error: (error, context) => {
    console.error('Error occurred:', error);
  }
}));
```

#### Creating Custom Error Classes

You can create your own error classes with status codes:

```typescript
// Define a custom error class
class AppError extends Error {
  constructor(message: string, public status: number) {
    super(message);
  }
}

// Use in routes
app.get('/admin', () => {
  throw new AppError('Forbidden', 403);
});

// Or create factory functions for common errors
const NotFoundError = (message: string) => {
  const error: any = new Error(message);
  error.status = 404;
  return error;
};

const UnauthorizedError = (message: string) => {
  const error: any = new Error(message);
  error.status = 401;
  return error;
};

// Use the factories
app.get('/user/:id', ({ params }) => {
  if (!user) {
    throw NotFoundError('User not found');
  }
  return user;
});
```

### CORS Middleware

Enable Cross-Origin Resource Sharing:

```typescript
import { bunserve, cors } from 'bunserve';

const app = bunserve();

// Allow all origins (use cautiously in production)
app.use(cors());

// Custom configuration for specific origins
app.use(cors({
  origin: ['https://example.com', 'https://app.example.com'],  // Allow specific origins
  methods: ['GET', 'POST', 'PUT', 'DELETE'],                    // Allow specific HTTP methods
  allowed_headers: ['Content-Type', 'Authorization'],            // Allow specific headers
  credentials: true,                                             // Allow cookies/credentials
  max_age: 86400                                                 // Cache preflight for 24 hours
}));

// Dynamic origin validation with custom function
app.use(cors({
  origin: (origin) => {
    // Allow all .example.com subdomains
    return origin.endsWith('.example.com');
  }
}));
```

#### CORS Presets

Use the `preset` option for common CORS configurations:

```typescript
import { cors } from 'bunserve';

// Development preset (allows localhost)
app.use(cors({ preset: 'development' }));

// Production preset (requires explicit origins)
app.use(cors({
  preset: 'production',
  allowed_origins: ['https://example.com', 'https://app.example.com']
}));

// Allow all preset (least secure)
app.use(cors({ preset: 'allow_all' }));

// Preset with custom overrides
app.use(cors({
  preset: 'development',
  max_age: 3600  // Override the preset's max_age
}));
```

### Logger Middleware

Log HTTP requests:

```typescript
import { bunserve, logger } from 'bunserve';

const app = bunserve();

// Development logging (with colors and timing)
app.use(logger({ format: 'dev' }));
// Output: [abc123] GET /api/users 200 15ms

// Production logging (with timestamps)
app.use(logger({ format: 'combined' }));
// Output: 2024-01-01T12:00:00.000Z [abc123] GET /api/users 200 15ms

// Minimal logging (just method and path)
app.use(logger({ format: 'tiny' }));
// Output: GET /api/users
```

#### Logger Options

```typescript
app.use(logger({
  format: 'dev', // 'dev', 'combined', 'common', 'short', 'tiny'

  // Custom log function
  log: (message) => {
    // Send to logging service
    console.log(message)
  },

  // Skip certain paths
  skip: (path) => {
    return path === '/health' || path.startsWith('/metrics')
  }
}))
```

#### Logger Presets

Use the `preset` option for common logging configurations:

```typescript
import { logger } from 'bunserve';

// Development preset (colored output with request IDs)
app.use(logger({ preset: 'development' }));

// Production preset (timestamped combined format)
app.use(logger({ preset: 'production' }));

// Minimal preset (just method and path)
app.use(logger({ preset: 'minimal' }));

// Preset with custom overrides
app.use(logger({
  preset: 'development',
  skip: (path) => path === '/health'  // Override the preset's skip function
}));
```

## Route-Specific Middleware

Apply middleware to specific routes:

```typescript
// Authentication middleware that checks for auth token
// Note: The first parameter is the context object - we destructure request and set from it
const requireAuth = async ({ request, set }, next) => {
  const token = request.headers.get('authorization');

  if (!token) {
    set.status = 401;
    return { error: 'Unauthorized' };
  }

  // Verify token...
  await next();
};

// Apply to specific routes
// Public route - no middleware required
app.get('/public', () => 'Public data');
// Private route - requires authentication
app.get('/private', [requireAuth], () => 'Private data');

// Multiple middleware - executes in array order
const requireAdmin = async ({ request, set }, next) => {
  // Check if user is admin...
  await next();
};

// Admin route - requires both auth and admin middleware
app.get('/admin', [requireAuth, requireAdmin], () => {
  return 'Admin data';
});
```

## Custom Middleware

### Authentication Middleware

```typescript
import { bunserve, Context } from 'bunserve';

const app = bunserve();

// Authentication middleware with JWT verification
// The context parameter is destructured to { request, set }
const authenticate = async ({ request, set }, next) => {
  // Extract Bearer token from Authorization header
  const token = request.headers.get('authorization')?.replace('Bearer ', '');

  if (!token) {
    set.status = 401;
    return { error: 'No token provided' };
  }

  try {
    // Verify JWT token (example)
    const user = verifyJWT(token);

    // Store user in request-scoped Context for use in route handlers
    Context.set({ user });

    await next();
  } catch (error) {
    set.status = 401;
    return { error: 'Invalid token' };
  }
};

// Use in routes - access user from context
app.get('/profile', [authenticate], () => {
  // Retrieve user from Context with type safety
  const { user } = Context.get<{ user: User }>();
  return { user };
});
```

### Rate Limiting Middleware

```typescript
// In-memory store for rate limit tracking
const rate_limiter = new Map<string, { count: number; reset: number }>();

// Rate limiting middleware factory
const rate_limit = (max_requests: number, window_ms: number) => {
  return async ({ request, set }, next) => {
    // Get client IP from headers
    const ip = request.headers.get('x-forwarded-for') || 'unknown';
    const now = Date.now();

    const limit = rate_limiter.get(ip);

    if (limit && now < limit.reset) {
      // Within the time window
      if (limit.count >= max_requests) {
        // Rate limit exceeded
        set.status = 429;
        set.headers['Retry-After'] = String(Math.ceil((limit.reset - now) / 1000));
        return { error: 'Too many requests' };
      }
      limit.count++;
    } else {
      // New time window - reset counter
      rate_limiter.set(ip, {
        count: 1,
        reset: now + window_ms
      });
    }

    await next();
  };
};

// Apply rate limit: 100 requests per 15 minutes
app.use(rate_limit(100, 15 * 60 * 1000));
```

### Caching Middleware

```typescript
const cache = new Map<string, { data: any; expires: number }>()

const cache_middleware = (duration_ms: number) => {
  return async ({ request, set }, next) => {
    const cache_key = request.url

    const cached = cache.get(cache_key)
    if (cached && Date.now() < cached.expires) {
      return cached.data
    }

    await next()

    // Cache the response
    // Note: In real implementation, you'd need to intercept the response
  }
}
```

### Request ID Middleware

```typescript
const request_id_middleware = async ({ set }, next) => {
  const request_id = crypto.randomUUID()

  // Add to response headers
  set.headers['X-Request-ID'] = request_id

  // Store in context
  Context.set({ request_id })

  await next()
}

app.use(request_id_middleware)
```

### Performance Monitoring

```typescript
const perf_monitor = async ({ request }, next) => {
  const start = performance.now()

  await next()

  const duration = performance.now() - start
  console.log(`${request.method} ${request.url} took ${duration.toFixed(2)}ms`)
}

app.use(perf_monitor)
```

### Request Validation

```typescript
const validate_json = async ({ request, set }, next) => {
  if (request.method === 'POST' || request.method === 'PUT') {
    const content_type = request.headers.get('content-type')

    if (!content_type?.includes('application/json')) {
      set.status = 415
      return { error: 'Content-Type must be application/json' }
    }
  }

  await next()
}

app.use(validate_json)
```

## Middleware Patterns

### Conditional Middleware

```typescript
const conditional_middleware = (condition: boolean, middleware: Middleware) => {
  return async (context, next) => {
    if (condition) {
      await middleware(context, next)
    } else {
      await next()
    }
  }
}

// Only log in development
app.use(conditional_middleware(
  process.env.NODE_ENV === 'development',
  logger({ format: 'dev' })
))
```

### Composing Middleware

```typescript
const compose_middleware = (...middlewares: Middleware[]): Middleware => {
  return async (context, next) => {
    let index = 0

    const dispatch = async (): Promise<void> => {
      if (index < middlewares.length) {
        const middleware = middlewares[index++]
        await middleware(context, dispatch)
      } else {
        await next()
      }
    }

    await dispatch()
  }
}

// Use
const auth_stack = compose_middleware(
  authenticate,
  requireAdmin
)

app.get('/admin', [auth_stack], () => 'Admin')
```

### Async Middleware

```typescript
const db_middleware = async ({ set }, next) => {
  // Open database connection
  const db = await connect_to_database()

  try {
    Context.set({ db })
    await next()
  } finally {
    // Cleanup
    await db.close()
  }
}

app.use(db_middleware)
```

## Complete Example

Here's a production-ready middleware stack:

```typescript
import {
  bunserve,
  error_handler,
  cors,
  logger
} from 'bunserve'

const app = bunserve()

// 1. Error handling (should be first)
app.use(error_handler({
  include_stack: process.env.NODE_ENV === 'development'
}))

// 2. CORS - using preset
app.use(cors({
  preset: process.env.NODE_ENV === 'production' ? 'production' : 'development',
  allowed_origins: process.env.ALLOWED_ORIGINS?.split(',')
}))

// 3. Logging - using preset
app.use(logger({
  preset: process.env.NODE_ENV === 'development' ? 'development' : 'production',
  skip: (path) => path === '/health'
}))

// 4. Request ID
app.use(async ({ set }, next) => {
  set.headers['X-Request-ID'] = crypto.randomUUID()
  await next()
})

// 5. Rate limiting
app.use(rate_limit(100, 15 * 60 * 1000))

// 6. Authentication (route-specific)
const authenticate = async ({ request, set }, next) => {
  const token = request.headers.get('authorization')
  if (!token) {
    const error: any = new Error('Unauthorized');
    error.status = 401;
    throw error;
  }
  await next()
}

// Routes
app.get('/health', () => ({ status: 'ok' }))
app.get('/public', () => 'Public data')
app.get('/private', [authenticate], () => 'Private data')

app.listen(3000)
```

## Best Practices

### 1. Order Matters

```typescript
// Good: Error handler first
app.use(error_handler())
app.use(cors())
app.use(logger())

// Bad: Error handler last won't catch errors from other middleware
app.use(cors())
app.use(logger())
app.use(error_handler())
```

### 2. Always Call next()

```typescript
// Good
app.use(async ({}, next) => {
  console.log('Before')
  await next()
  console.log('After')
})

// Bad: Doesn't call next(), handler won't run
app.use(async ({}, next) => {
  console.log('Before')
  // Missing: await next()
})
```

### 3. Return Early for Errors

```typescript
// Good
app.use(async ({ request, set }, next) => {
  if (!request.headers.get('api-key')) {
    set.status = 401
    return { error: 'API key required' }
  }
  await next()
})

// Bad: Calls next() even after error
app.use(async ({ request, set }, next) => {
  if (!request.headers.get('api-key')) {
    set.status = 401
    // Should return here!
  }
  await next()
})
```

### 4. Use Context for Shared Data

```typescript
// Good: Share data via Context
app.use(async ({}, next) => {
  const user = await authenticate()
  Context.set({ user })
  await next()
})

app.get('/profile', () => {
  const { user } = Context.get<{ user: User }>()
  return { user }
})

// Bad: Can't access data from middleware
app.use(async ({}, next) => {
  const user = await authenticate()
  // How do we pass this to the handler?
  await next()
})
```

## Next Steps

- **[Error Handling](./05-error-handling.md)** - Advanced error handling patterns
- **[Response Handling](./responses.md)** - Different response types
- **[Examples](./07-examples.md)** - Complete middleware examples
- **[API Reference](./08-api-reference.md)** - Complete API documentation
