# Increment 0.2: Enhanced Response Helpers and Context Integration

## Overview
This increment enhances the response system with comprehensive helpers for different content types and integrates `@theinternetfolks/context` for request-scoped data sharing. This eliminates the need for prop drilling and provides Express-like flexibility.

## Objectives
- Implement multiple response type helpers (JSON, XML, HTML, images, CSV)
- Add cookie and header management utilities
- Integrate `@theinternetfolks/context` for request-scoped data
- Provide file serving and download capabilities
- Add caching helpers

## API Design

### Enhanced Response Types
```typescript
import { createRouter, createServer } from 'bunserve'
import { Context } from '@theinternetfolks/context'

const router = createRouter()

// JSON response (default)
router.get('/api/users', () => {
  return [
    { id: 1, name: 'John Doe' },
    { id: 2, name: 'Jane Smith' }
  ]
})

// Text response
router.get('/api/text', ({ set }) => {
  set.content = 'text'
  return 'Hello, World!'
})

// HTML response
router.get('/api/html', ({ set }) => {
  set.content = 'html'
  return `
    <!DOCTYPE html>
    <html>
      <head><title>Test</title></head>
      <body><h1>Hello, World!</h1></body>
    </html>
  `
})

// XML response
router.get('/api/xml', ({ set }) => {
  set.content = 'xml'
  return `<?xml version="1.0" encoding="UTF-8"?>
  <response>
    <message>Hello, World!</message>
    <timestamp>${Date.now()}</timestamp>
  </response>`
})

// Image response (base64)
router.get('/api/logo', ({ set }) => {
  set.content = 'png'
  set.cache = '1h' // Cache for 1 hour
  return 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+P+/HgAFhAJ/wlseKgAAAABJRU5ErkJggg=='
})

// SVG response
router.get('/api/icon', ({ set }) => {
  set.content = 'svg'
  set.cache = '30d' // Cache for 30 days
  return '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/></svg>'
})
```

### CSV File Downloads
```typescript
router.get('/api/export/users', ({ set }) => {
  set.content = { type: 'csv', filename: 'users' }
  
  const csvData = [
    ['Name', 'Email', 'Age'],
    ['John Doe', 'john@example.com', '25'],
    ['Jane Smith', 'jane@example.com', '30']
  ].map(row => row.join(',')).join('\n')
  
  return csvData
})

// Custom CSV filename with timestamp
router.get('/api/export/orders', ({ set }) => {
  const timestamp = new Date().toISOString().split('T')[0]
  set.content = { type: 'csv', filename: `orders-${timestamp}` }
  
  return generateOrdersCSV()
})
```

### Cookie Management
```typescript
router.post('/api/login', async ({ body, set }) => {
  const { email, password } = body
  const user = await authenticateUser(email, password)
  
  // Set authentication cookie
  set.cookies = [{
    name: 'auth_token',
    value: user.token,
    options: {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
    }
  }]
  
  // Set additional preferences cookie
  set.cookies.push({
    name: 'theme',
    value: 'dark',
    options: {
      maxAge: 30 * 24 * 60 * 60 * 1000 // 30 days
    }
  })
  
  return { success: true, user }
})

// Update cookie
router.post('/api/preferences', ({ body, set }) => {
  set.cookies = [{
    name: 'theme',
    value: body.theme,
    options: {
      maxAge: 30 * 24 * 60 * 60 * 1000
    }
  }]
  
  return { success: true }
})
```

### Context Integration
```typescript
import { Context } from '@theinternetfolks/context'

// Create server with context initialization
const server = createServer({
  router,
  beforeEach: (request) => {
    Context.init()
    Context.set({
      requestId: generateId(),
      startTime: Date.now(),
      ip: request.headers.get('x-forwarded-for') || 'unknown',
      userAgent: request.headers.get('user-agent')
    })
  }
})

// Logging middleware using context
router.use(async ({ request }, next) => {
  const context = Context.get<{ requestId: string; startTime: number }>()
  console.log(`[${context.requestId}] ${request.method} ${request.url}`)
  
  const start = Date.now()
  await next()
  
  const duration = Date.now() - start
  console.log(`[${context.requestId}] Completed in ${duration}ms`)
})

// Authentication middleware
router.use(async ({ request, set }, next) => {
  const token = request.headers.get('authorization')
  
  if (!token) {
    set.status = 401
    return { error: 'Unauthorized' }
  }
  
  const user = await verifyToken(token)
  Context.set({ user }) // Store user in context
  
  await next()
})

// Route handler using context
router.get('/api/profile', () => {
  const { user, requestId } = Context.get<{ user: User; requestId: string }>()
  
  return {
    user,
    requestId,
    timestamp: Date.now()
  }
})

// Context works across async operations
router.get('/api/async-test', async () => {
  const context = Context.get<{ requestId: string }>()
  
  // Context is preserved in setTimeout
  setTimeout(() => {
    console.log(`Async operation completed for request ${context.requestId}`)
  }, 1000)
  
  return { message: 'Async test started' }
})
```

### Advanced Header Management
```typescript
router.get('/api/custom-headers', ({ set }) => {
  set.headers = {
    'X-API-Version': '1.0.0',
    'X-Rate-Limit-Remaining': '99',
    'X-Request-ID': Context.get('requestId'),
    'Content-Security-Policy': "default-src 'self'"
  }
  
  return { message: 'Custom headers set' }
})

// Security headers
router.use(({}, next) => {
  const set = {} as ResponseSetter // In practice, this comes from context
  
  set.headers = {
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block'
  }
  
  return next()
})
```

### File Serving
```typescript
router.get('/files/:filename', ({ params, set }) => {
  const filePath = `./uploads/${params.filename}`
  
  try {
    const file = Bun.file(filePath)
    const exists = await file.exists()
    
    if (!exists) {
      set.status = 404
      return { error: 'File not found' }
    }
    
    // Set appropriate content type
    const ext = params.filename.split('.').pop()?.toLowerCase()
    const mimeType = getMimeType(ext)
    
    set.headers = {
      'Content-Type': mimeType,
      'Content-Disposition': `inline; filename="${params.filename}"`
    }
    
    return file
  } catch (error) {
    set.status = 500
    return { error: 'Failed to serve file' }
  }
})

// Force download
router.get('/download/:filename', ({ params, set }) => {
  set.headers = {
    'Content-Disposition': `attachment; filename="${params.filename}"`
  }
  
  return Bun.file(`./downloads/${params.filename}`)
})
```

## Implementation Details

### Enhanced Response Setter
```typescript
interface ResponseSetter {
  status: number
  content: ResponseContent
  headers: Record<string, string>
  redirect?: string
  cookies?: Cookie[]
  cache?: string
}

type ResponseContent = 
  | 'json'                           // JSON response (default)
  | 'text'                           // Plain text
  | 'html'                           // HTML response
  | 'xml'                            // XML response
  | 'png' | 'svg' | 'gif' | 'webp'   // Image types (base64)
  | { type: 'csv'; filename: string } // CSV download

interface Cookie {
  name: string
  value: string
  options?: {
    httpOnly?: boolean
    secure?: boolean
    sameSite?: 'strict' | 'lax' | 'none'
    maxAge?: number
    domain?: string
    path?: string
    expires?: Date
  }
}
```

### Response Builder Enhancement
```typescript
function buildResponse(result: any, set: ResponseSetter): Response {
  // Handle redirects
  if (set.redirect) {
    return Response.redirect(set.redirect, set.status || 302)
  }
  
  // Handle different content types
  let body: string | ArrayBuffer | ReadableStream = ''
  let contentType = 'application/json'
  let contentLength: number | undefined
  
  switch (set.content) {
    case 'json':
      body = JSON.stringify(result)
      contentType = 'application/json'
      contentLength = body.length
      break
      
    case 'text':
      body = String(result)
      contentType = 'text/plain'
      contentLength = body.length
      break
      
    case 'html':
      body = String(result)
      contentType = 'text/html'
      contentLength = body.length
      break
      
    case 'xml':
      body = String(result)
      contentType = 'application/xml'
      contentLength = body.length
      break
      
    case 'png':
    case 'gif':
    case 'webp':
      body = Buffer.from(result, 'base64')
      contentType = `image/${set.content}`
      contentLength = body.byteLength
      break
      
    case 'svg':
      body = String(result)
      contentType = 'image/svg+xml'
      contentLength = body.length
      break
      
    case { type: 'csv' }:
      body = String(result)
      contentType = 'text/csv'
      contentLength = body.length
      break
  }
  
  // Build headers
  const headers: Record<string, string> = {
    'Content-Type': contentType,
    ...set.headers
  }
  
  // Add content length if available
  if (contentLength !== undefined) {
    headers['Content-Length'] = String(contentLength)
  }
  
  // Add cache headers
  if (set.cache) {
    headers['Cache-Control'] = `public, max-age=${parseCacheDuration(set.cache)}`
  }
  
  // Add cookies
  if (set.cookies && set.cookies.length > 0) {
    headers['Set-Cookie'] = set.cookies.map(cookie => 
      formatCookie(cookie)
    ).join(', ')
  }
  
  return new Response(body, {
    status: set.status || 200,
    headers
  })
}
```

### Context Integration
```typescript
interface ServerOptions {
  router: Router
  port?: number
  beforeEach?: (request: Request) => void
  afterEach?: (request: Request, response: Response) => void
}

function createServer(options: ServerOptions) {
  const { router, beforeEach, afterEach } = options
  
  const server = Bun.serve({
    async fetch(request) {
      // Initialize context
      if (beforeEach) {
        beforeEach(request)
      }
      
      try {
        const response = await processRequest(request, router)
        
        // Cleanup context
        if (afterEach) {
          afterEach(request, response)
        }
        
        return response
      } catch (error) {
        console.error('Request error:', error)
        return new Response('Internal Server Error', { status: 500 })
      }
    }
  })
  
  return server
}
```

### Cookie Formatter
```typescript
function formatCookie(cookie: Cookie): string {
  const { name, value, options = {} } = cookie
  
  let cookieString = `${name}=${encodeURIComponent(value)}`
  
  if (options.httpOnly) {
    cookieString += '; HttpOnly'
  }
  
  if (options.secure) {
    cookieString += '; Secure'
  }
  
  if (options.sameSite) {
    cookieString += `; SameSite=${options.sameSite}`
  }
  
  if (options.maxAge) {
    cookieString += `; Max-Age=${options.maxAge}`
  }
  
  if (options.path) {
    cookieString += `; Path=${options.path}`
  }
  
  if (options.domain) {
    cookieString += `; Domain=${options.domain}`
  }
  
  if (options.expires) {
    cookieString += `; Expires=${options.expires.toUTCString()}`
  }
  
  return cookieString
}
```

## Testing Strategy

### Response Type Tests
```typescript
describe('Response Types', () => {
  test('handles CSV downloads', async () => {
    const router = createRouter()
    router.get('/export', ({ set }) => {
      set.content = { type: 'csv', filename: 'test' }
      return 'Name,Email\nJohn,john@example.com'
    })
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/export'))
    
    expect(response.headers.get('Content-Type')).toBe('text/csv')
    expect(response.headers.get('Content-Disposition'))
      .toContain('filename="test"')
  })
  
  test('handles image responses', async () => {
    const router = createRouter()
    router.get('/logo', ({ set }) => {
      set.content = 'png'
      return 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+P+/HgAFhAJ/wlseKgAAAABJRU5ErkJggg=='
    })
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/logo'))
    
    expect(response.headers.get('Content-Type')).toBe('image/png')
  })
})
```

### Context Tests
```typescript
describe('Context Integration', () => {
  test('preserves context across middleware and handlers', async () => {
    const router = createRouter()
    
    router.use(async ({}, next) => {
      Context.set({ test: 'middleware' })
      await next()
    })
    
    router.get('/test', () => {
      const context = Context.get<{ test: string }>()
      return { test: context.test }
    })
    
    const server = createServer({
      router,
      beforeEach: () => Context.init()
    })
    
    const response = await server.fetch(new Request('http://localhost/test'))
    const data = await response.json()
    
    expect(data.test).toBe('middleware')
  })
  
  test('context works with async operations', async () => {
    const router = createRouter()
    
    router.get('/async', async () => {
      const context = Context.get<{ requestId: string }>()
      
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve({ 
            requestId: context.requestId,
            async: true 
          })
        }, 10)
      })
    })
    
    const server = createServer({
      router,
      beforeEach: (req) => {
        Context.init()
        Context.set({ requestId: 'test-123' })
      }
    })
    
    const response = await server.fetch(new Request('http://localhost/async'))
    const data = await response.json()
    
    expect(data.requestId).toBe('test-123')
  })
})
```

## Performance Considerations

### Response Building Optimization
- Lazy response building (only when needed)
- Efficient string concatenation
- Minimal object creation
- Cached MIME type lookups

### Context Performance
- Zero overhead for unused context
- Efficient AsyncLocalStorage usage
- Context data isolation
- No memory leaks

## Documentation

### API Reference
- ResponseContent type variants
- Cookie options and security
- Context lifecycle methods
- File serving helpers

### Examples
- Complete file download system
- Authentication with context
- Response caching strategies
- Security headers setup

## Success Criteria

### Functional Requirements
- [ ] Multiple response type support
- [ ] CSV file download with custom filenames
- [ ] Cookie management with security options
- [ ] `@theinternetfolks/context` integration
- [ ] File serving capabilities
- [ ] Advanced header management

### Performance Requirements
- [ ] <2ms response building time
- [ ] No context overhead for unused features
- [ ] Efficient memory usage
- [ ] Fast MIME type detection

### Type Safety Requirements
- [ ] Full response type inference
- [ ] Cookie option type safety
- [ ] Context data type safety
- [ ] File serving type safety

## Next Steps

This increment completes the response and context foundation. The next increment (1.1) will focus on the Express-style middleware system with route-specific middleware chains and error handling patterns.