# Increment 0.1: Basic Route Definition

## Overview
This increment implements the core foundation of the BunServe library, focusing on basic route definition and parameter extraction. This is the building block upon which all other features will be built.

## Objectives
- Create the core BunServe class
- Implement basic GET route handling
- Support URL parameter extraction
- Provide type-safe route definitions
- Establish the foundational architecture

## API Design

### Basic Usage
```typescript
import { BunServe } from 'bunserve'

const app = new BunServe()

// Simple string response
app.get('/hello', () => 'Hello World!')

// JSON response with parameters
app.get('/users/:id', ({ params }) => {
  return { id: params.id, name: 'John Doe' }
})

// Multiple parameters
app.get('/posts/:postId/comments/:commentId', ({ params }) => {
  return { 
    postId: params.postId, 
    commentId: params.commentId 
  }
})

app.listen(3000)
```

### Type System
```typescript
// Automatic parameter type inference
app.get('/users/:id', ({ params }) => {
  // params.id is inferred as string
  return { id: params.id }
})

// Multiple parameter inference
app.get('/orgs/:orgId/repos/:repoId', ({ params }) => {
  // params: { orgId: string; repoId: string }
  return { orgId: params.orgId, repoId: params.repoId }
})
```

## Implementation Details

### Core Components

#### 1. Route Store
```typescript
interface Route {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'OPTIONS' | 'HEAD'
  path: string
  handler: RouteHandler
  pattern: RegExp
  paramNames: string[]
}

class RouteStore {
  private routes: Route[] = []
  
  add(route: Route): void
  find(method: string, path: string): RouteMatch | null
}
```

#### 2. Parameter Extraction
```typescript
// Convert '/users/:id' to regex pattern and extract parameter names
function parseRoutePattern(path: string): { pattern: RegExp; paramNames: string[] } {
  const paramNames: string[] = []
  const pattern = path
    .replace(/:(\w+)/g, (_, paramName) => {
      paramNames.push(paramName)
      return '([^/]+)'
    })
    .replace(/\*/g, '.*')
  
  return {
    pattern: new RegExp(`^${pattern}$`),
    paramNames
  }
}
```

#### 3. Request Processing
```typescript
async function processRequest(request: Request): Promise<Response> {
  const url = new URL(request.url)
  const method = request.method
  const path = url.pathname
  
  const routeMatch = routeStore.find(method, path)
  
  if (!routeMatch) {
    return new Response('Not Found', { status: 404 })
  }
  
  const context = {
    request,
    params: routeMatch.params,
    query: Object.fromEntries(url.searchParams),
    set: new ResponseSetter()
  }
  
  const result = await routeMatch.route.handler(context)
  return buildResponse(result, context.set)
}
```

### TypeScript Types
```typescript
type RouteParams<T extends string> = 
  T extends `${string}:${infer Param}/${infer Rest}`
    ? { [K in Param | keyof RouteParams<Rest>]: string }
    : T extends `${string}:${infer Param}`
      ? { [K in Param]: string }
      : {}

interface RequestContext<TPath extends string> {
  request: Request
  params: RouteParams<TPath>
  query: Record<string, string>
  set: ResponseSetter
}

type RouteHandler<TPath extends string> = (
  context: RequestContext<TPath>
) => any

class ResponseSetter {
  status: number = 200
  headers: Record<string, string> = {}
}
```

## Testing Strategy

### Unit Tests
```typescript
describe('Route Pattern Parsing', () => {
  test('extracts simple parameter', () => {
    const result = parseRoutePattern('/users/:id')
    expect(result.paramNames).toEqual(['id'])
    expect('/users/123'.match(result.pattern)).toBeTruthy()
  })
  
  test('extracts multiple parameters', () => {
    const result = parseRoutePattern('/orgs/:orgId/repos/:repoId')
    expect(result.paramNames).toEqual(['orgId', 'repoId'])
  })
})

describe('Route Matching', () => {
  test('matches exact routes', () => {
    const routeStore = new RouteStore()
    routeStore.add({
      method: 'GET',
      path: '/hello',
      handler: () => 'Hello'
    })
    
    const match = routeStore.find('GET', '/hello')
    expect(match).toBeDefined()
  })
  
  test('matches parameterized routes', () => {
    const routeStore = new RouteStore()
    routeStore.add({
      method: 'GET',
      path: '/users/:id',
      handler: ({ params }) => params.id
    })
    
    const match = routeStore.find('GET', '/users/123')
    expect(match?.params.id).toBe('123')
  })
})
```

### Integration Tests
```typescript
describe('Full Request Processing', () => {
  test('handles simple route', async () => {
    const app = new BunServe()
    app.get('/test', () => 'test response')
    
    const response = await app.fetch(new Request('http://localhost:3000/test'))
    expect(response.status).toBe(200)
    expect(await response.text()).toBe('test response')
  })
  
  test('handles route with parameters', async () => {
    const app = new BunServe()
    app.get('/users/:id', ({ params }) => ({ id: params.id }))
    
    const response = await app.fetch(new Request('http://localhost:3000/users/123'))
    const data = await response.json()
    expect(data.id).toBe('123')
  })
})
```

## Performance Considerations

### Route Matching Optimization
- Pre-compile route patterns during registration
- Use trie data structure for route matching (future optimization)
- Cache frequently accessed routes

### Memory Usage
- Minimal object creation during request processing
- Reuse response objects where possible
- Efficient parameter extraction

## Error Handling

### Route Not Found
```typescript
// Automatic 404 response for unmatched routes
app.fetch(new Request('http://localhost:3000/unknown'))
// Returns: Response with status 404
```

### Handler Errors
```typescript
// Basic error handling for route handler exceptions
app.get('/error', () => {
  throw new Error('Something went wrong')
})
// Returns: Response with status 500
```

## Documentation

### API Reference
- `BunServe` class constructor
- `app.get(path, handler)` method
- `app.listen(port)` method
- `RequestContext` interface
- `ResponseSetter` interface

### Examples
- Basic "Hello World" server
- Simple JSON API
- Parameterized routes
- Error handling examples

## Success Criteria

### Functional Requirements
- [ ] Basic GET route handling
- [ ] URL parameter extraction
- [ ] Type-safe parameter inference
- [ ] JSON response formatting
- [ ] Query string parsing
- [ ] Basic error handling

### Performance Requirements
- [ ] <1ms route matching time
- [ ] <2KB memory overhead per request
- [ ] 1000+ requests/second baseline

### Type Safety Requirements
- [ ] Full parameter type inference
- [ ] Handler return type validation
- [ ] No explicit type annotations needed for basic usage

## Next Steps

This increment establishes the foundation for all future features. The next increment (0.2) will build upon this foundation to add support for all HTTP methods and request body parsing.