# Increment 0.2: HTTP Method Support

## Overview
This increment extends the basic routing foundation to support all standard HTTP methods (POST, PUT, DELETE, PATCH, OPTIONS, HEAD) and implements request body parsing with proper content-type handling.

## Objectives
- Add support for all HTTP methods
- Implement request body parsing (JSON, form data, text)
- Add content-type handling
- Provide method-specific route matching
- Maintain type safety across all methods

## API Design

### Extended Usage
```typescript
import { BunServe } from 'bunserve'

const app = new BunServe()

// GET - Retrieve resources
app.get('/users', () => {
  return [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]
})

// POST - Create resources
app.post('/users', async ({ body }) => {
  const user = await createUser(body)
  return { success: true, user }
})

// PUT - Update resources
app.put('/users/:id', async ({ params, body }) => {
  const user = await updateUser(params.id, body)
  return { success: true, user }
})

// DELETE - Remove resources
app.delete('/users/:id', async ({ params }) => {
  await deleteUser(params.id)
  return { success: true }
})

// PATCH - Partial updates
app.patch('/users/:id', async ({ params, body }) => {
  const user = await patchUser(params.id, body)
  return { success: true, user }
})

// OPTIONS - CORS preflight
app.options('/users', () => {
  return new Response(null, {
    headers: {
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    }
  })
})

// HEAD - Headers only
app.head('/users', () => {
  return new Response(null, {
    headers: { 'Content-Length': '1024' }
  })
})

app.listen(3000)
```

### Body Parsing with Type Safety
```typescript
interface CreateUserInput {
  name: string
  email: string
  age?: number
}

interface User {
  id: string
  name: string
  email: string
  createdAt: string
}

// TypeScript infers body type
app.post<CreateUserInput, User>('/users', async ({ body }) => {
  // body is properly typed as CreateUserInput
  return await createUser(body)
})

app.put<Partial<User>, User>('/users/:id', async ({ params, body }) => {
  // body is typed as Partial<User>
  return await updateUser(params.id, body)
})
```

## Implementation Details

### Extended Route Store
```typescript
interface Route<T = any> {
  method: HttpMethod
  path: string
  handler: RouteHandler<T>
  pattern: RegExp
  paramNames: string[]
  bodyParser?: BodyParser
}

type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'OPTIONS' | 'HEAD'

class RouteStore {
  private routes: Map<HttpMethod, Route[]> = new Map()
  
  add<T>(method: HttpMethod, path: string, handler: RouteHandler<T>): void {
    const route: Route<T> = {
      method,
      path,
      handler,
      ...parseRoutePattern(path),
      bodyParser: getBodyParser(method)
    }
    
    if (!this.routes.has(method)) {
      this.routes.set(method, [])
    }
    this.routes.get(method)!.push(route)
  }
  
  find(method: string, path: string): RouteMatch | null {
    const methodRoutes = this.routes.get(method as HttpMethod)
    if (!methodRoutes) return null
    
    for (const route of methodRoutes) {
      const match = route.pattern.exec(path)
      if (match) {
        const params = this.extractParams(route.paramNames, match)
        return { route, params }
      }
    }
    
    return null
  }
}
```

### Body Parsing System
```typescript
interface BodyParser {
  canParse(contentType: string): boolean
  parse(request: Request): Promise<any>
}

class JsonBodyParser implements BodyParser {
  canParse(contentType: string): boolean {
    return contentType.includes('application/json')
  }
  
  async parse(request: Request): Promise<any> {
    return await request.json()
  }
}

class FormBodyParser implements BodyParser {
  canParse(contentType: string): boolean {
    return contentType.includes('application/x-www-form-urlencoded')
  }
  
  async parse(request: Request): Promise<any> {
    const formData = await request.formData()
    return Object.fromEntries(formData)
  }
}

class TextBodyParser implements BodyParser {
  canParse(contentType: string): boolean {
    return contentType.includes('text/plain')
  }
  
  async parse(request: Request): Promise<any> {
    return await request.text()
  }
}

function getBodyParser(method: HttpMethod): BodyParser | undefined {
  // Only parse body for methods that typically have one
  const bodyMethods = ['POST', 'PUT', 'PATCH']
  return bodyMethods.includes(method) ? new CompositeBodyParser() : undefined
}
```

### Extended Request Processing
```typescript
async function processRequest(request: Request): Promise<Response> {
  const url = new URL(request.url)
  const method = request.method
  const path = url.pathname
  
  const routeMatch = routeStore.find(method, path)
  
  if (!routeMatch) {
    return new Response('Not Found', { status: 404 })
  }
  
  // Parse body if applicable
  let body: any = null
  if (routeMatch.route.bodyParser) {
    const contentType = request.headers.get('content-type') || ''
    if (routeMatch.route.bodyParser.canParse(contentType)) {
      try {
        body = await routeMatch.route.bodyParser.parse(request)
      } catch (error) {
        return new Response('Invalid request body', { status: 400 })
      }
    }
  }
  
  const context = {
    request,
    params: routeMatch.params,
    query: Object.fromEntries(url.searchParams),
    body,
    set: new ResponseSetter()
  }
  
  const result = await routeMatch.route.handler(context)
  return buildResponse(result, context.set)
}
```

### TypeScript Extensions
```typescript
interface RequestContext<TPath extends string, TBody = any> {
  request: Request
  params: RouteParams<TPath>
  query: Record<string, string>
  body: TBody
  set: ResponseSetter
}

type RouteHandler<TPath extends string, TBody = any> = (
  context: RequestContext<TPath, TBody>
) => any

// Extended BunServe class with all HTTP methods
class BunServe {
  get<TPath extends string>(path: TPath, handler: RouteHandler<TPath>): void
  post<TPath extends string, TBody = any>(path: TPath, handler: RouteHandler<TPath, TBody>): void
  put<TPath extends string, TBody = any>(path: TPath, handler: RouteHandler<TPath, TBody>): void
  delete<TPath extends string>(path: TPath, handler: RouteHandler<TPath>): void
  patch<TPath extends string, TBody = any>(path: TPath, handler: RouteHandler<TPath, TBody>): void
  options<TPath extends string>(path: TPath, handler: RouteHandler<TPath>): void
  head<TPath extends string>(path: TPath, handler: RouteHandler<TPath>): void
}
```

## Testing Strategy

### HTTP Method Tests
```typescript
describe('HTTP Methods', () => {
  let app: BunServe
  
  beforeEach(() => {
    app = new BunServe()
  })
  
  test('GET request', async () => {
    app.get('/test', () => 'GET response')
    const response = await app.fetch(new Request('http://localhost/test', { method: 'GET' }))
    expect(await response.text()).toBe('GET response')
  })
  
  test('POST request with JSON body', async () => {
    app.post('/users', ({ body }) => ({ received: body }))
    const response = await app.fetch(new Request('http://localhost/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'John' })
    }))
    const data = await response.json()
    expect(data.received.name).toBe('John')
  })
  
  test('PUT request with form data', async () => {
    app.put('/users/:id', ({ params, body }) => ({ id: params.id, data: body }))
    const formData = new FormData()
    formData.append('name', 'Jane')
    
    const response = await app.fetch(new Request('http://localhost/users/123', {
      method: 'PUT',
      body: formData
    }))
    const data = await response.json()
    expect(data.id).toBe('123')
  })
})
```

### Body Parsing Tests
```typescript
describe('Body Parsing', () => {
  test('parses JSON body', async () => {
    const app = new BunServe()
    app.post('/json', ({ body }) => body)
    
    const response = await app.fetch(new Request('http://localhost/json', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: 'Hello' })
    }))
    
    expect(await response.json()).toEqual({ message: 'Hello' })
  })
  
  test('parses form data', async () => {
    const app = new BunServe()
    app.post('/form', ({ body }) => body)
    
    const formData = new URLSearchParams()
    formData.append('name', 'John')
    formData.append('email', 'john@example.com')
    
    const response = await app.fetch(new Request('http://localhost/form', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: formData
    }))
    
    expect(await response.json()).toEqual({
      name: 'John',
      email: 'john@example.com'
    })
  })
  
  test('handles invalid JSON', async () => {
    const app = new BunServe()
    app.post('/json', ({ body }) => body)
    
    const response = await app.fetch(new Request('http://localhost/json', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: 'invalid json'
    }))
    
    expect(response.status).toBe(400)
  })
})
```

## Error Handling

### Method Not Allowed
```typescript
// Returns 405 for methods not defined on a route
app.get('/users', () => [])
// POST to /users returns 405 if no POST handler defined
```

### Content-Type Mismatch
```typescript
// Returns 400 for unsupported content types
app.post('/json-only', ({ body }) => body)
// POST with text/plain content returns 400
```

### Body Parsing Errors
```typescript
// Returns 400 for malformed request bodies
app.post('/users', ({ body }) => createUser(body))
// Invalid JSON returns 400 with error message
```

## Performance Considerations

### Body Parsing Optimization
- Lazy body parsing (only when needed)
- Content-type based parser selection
- Stream parsing for large payloads (future optimization)

### Route Matching
- Method-based route filtering
- Efficient pattern matching
- Minimal overhead for simple routes

## Documentation

### API Reference
- All HTTP method functions
- Body parsing behavior
- Error handling
- Type safety features

### Examples
- Complete REST API example
- Form handling
- File upload preparation (future increment)
- CORS preflight handling

## Success Criteria

### Functional Requirements
- [ ] Support for all HTTP methods
- [ ] JSON body parsing
- [ ] Form data parsing
- [ ] Text body parsing
- [ ] Content-type detection
- [ ] Method-specific error handling

### Type Safety Requirements
- [ ] Body type inference
- [ ] Method-specific handler types
- [ ] Request/response type preservation
- [ ] Content-type validation

### Performance Requirements
- [ ] <5ms body parsing time
- [ ] <1KB additional memory overhead
- [ ] No performance regression for GET requests

## Next Steps

This increment completes the basic HTTP functionality. The next phase (1.1) will focus on enhanced type safety through schema validation and improved type inference for complex request/response patterns.