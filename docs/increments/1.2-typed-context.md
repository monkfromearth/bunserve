# Increment 1.2: Typed Context Objects

## Overview
This increment introduces a strongly-typed context system that allows developers to define and inject custom context objects throughout their application. This enables type-safe access to user sessions, database connections, configuration, and other application-specific data.

## Objectives
- Create a generic context system
- Support context augmentation through middleware
- Provide type-safe context access
- Enable dependency injection patterns
- Maintain type safety across the application

## API Design

### Context-based Route Handlers
```typescript
import { BunServe, Context } from 'bunserve'

// Define application context
interface AppContext {
  db: Database
  config: AppConfig
  logger: Logger
}

// Extend with user-specific context
interface UserContext extends AppContext {
  user: User
  session: Session
}

// Create app with context
const app = new BunServe<AppContext>()

// Add context through middleware
app.use(async (ctx, next) => {
  ctx.db = await connectDatabase()
  ctx.config = loadConfig()
  ctx.logger = createLogger()
  await next()
})

// Route with typed context
app.get('/profile', {
  handler: (ctx: UserContext) => {
    // TypeScript knows ctx.user exists
    return {
      name: ctx.user.name,
      email: ctx.user.email,
      preferences: ctx.user.preferences
    }
  }
})

// Route with database access
app.get('/posts', {
  handler: (ctx: AppContext) => {
    // TypeScript knows ctx.db exists
    return ctx.db.posts.findMany()
  }
})
```

### Context Inheritance and Composition
```typescript
// Base context
interface BaseContext {
  request: RequestContext
  logger: Logger
  config: Config
}

// Auth context
interface AuthContext extends BaseContext {
  user: User | null
  session: Session | null
}

// Database context
interface DatabaseContext extends BaseContext {
  db: Database
  transaction: Transaction | null
}

// Combined context
interface AppContext extends AuthContext, DatabaseContext {
  cache: Cache
}

// Use with different context levels
app.get('/public', {
  handler: (ctx: BaseContext) => {
    ctx.logger.info('Public endpoint accessed')
    return { message: 'Hello World' }
  }
})

app.get('/user', {
  middleware: [requireAuth], // Adds user to context
  handler: (ctx: AuthContext) => {
    return { user: ctx.user }
  }
})

app.get('/admin', {
  middleware: [requireAuth, requireAdmin],
  handler: (ctx: AppContext) => {
    return { 
      user: ctx.user,
      stats: ctx.db.getAdminStats(),
      cached: ctx.cache.get('admin_stats')
    }
  }
})
```

## Implementation Details

### Context System Architecture
```typescript
// Base context interface
interface ContextBase {
  request: Request
  params: Record<string, string>
  query: Record<string, string>
  body: any
  set: ResponseSetter
  store: Record<string, any> // Runtime context storage
}

// Generic context type
type Context<T extends Record<string, any> = {}> = ContextBase & T

// Context-aware route handler
type ContextRouteHandler<TContext extends Context> = (
  context: TContext
) => Promise<any> | any

// Middleware with context
type ContextMiddleware<TContext extends Context> = (
  context: TContext,
  next: () => Promise<void>
) => Promise<void>
```

### Context Builder System
```typescript
class ContextBuilder<TBaseContext extends Context = Context> {
  private middlewares: ContextMiddleware<any>[] = []
  private contextExtensions: Record<string, any> = {}
  
  use<TExtendedContext extends Context>(
    middleware: ContextMiddleware<TExtendedContext>
  ): ContextBuilder<TExtendedContext> {
    this.middlewares.push(middleware as any)
    return this as any
  }
  
  extend<TExtension extends Record<string, any>>(
    extension: TExtension
  ): ContextBuilder<TBaseContext & TExtension> {
    Object.assign(this.contextExtensions, extension)
    return this as any
  }
  
  build(): (request: Request) => Promise<TBaseContext> {
    return async (request: Request) => {
      const baseContext: ContextBase = {
        request,
        params: {},
        query: {},
        body: null,
        set: new ResponseSetter(),
        store: {}
      }
      
      const context = { ...baseContext, ...this.contextExtensions } as TBaseContext
      
      // Execute middleware chain
      for (const middleware of this.middlewares) {
        await middleware(context, async () => {})
      }
      
      return context
    }
  }
}
```

### Type-safe Context Injection
```typescript
// Context provider middleware
function createProvider<T extends Record<string, any>>(
  name: keyof T,
  provider: () => Promise<T[keyof T]>
): ContextMiddleware<Context & T> {
  return async (context, next) => {
    context[name] = await provider()
    await next()
  }
}

// Usage
app.use(createProvider('db', () => connectToDatabase()))
app.use(createProvider('cache', () => connectToRedis()))

// Context-aware handler
app.get('/data', {
  handler: async (ctx: Context<{ db: Database; cache: Cache }>) => {
    const cached = await ctx.cache.get('data')
    if (cached) return cached
    
    const data = await ctx.db.query('SELECT * FROM data')
    await ctx.cache.set('data', data, { ttl: 3600 })
    return data
  }
})
```

### Context Validation
```typescript
// Context schema validation
interface ContextSchema<T> {
  validate: (context: Context) => context is Context & T
}

function validateContext<T>(
  context: Context,
  schema: ContextSchema<T>
): Context & T {
  if (!schema.validate(context)) {
    throw new Error('Context validation failed')
  }
  return context as Context & T
}

// Usage with routes
app.get('/protected', {
  handler: (ctx) => {
    const userContext = validateContext(ctx, {
      validate: (c): c is Context<{ user: User }> => 
        c.user !== undefined && typeof c.user === 'object'
    })
    
    return { user: userContext.user }
  }
})
```

### Async Context Building
```typescript
// Async context provider
class AsyncContextProvider<T extends Record<string, any>> {
  private providers: Map<keyof T, () => Promise<T[keyof T]>> = new Map()
  
  provide<K extends keyof T>(
    key: K,
    provider: () => Promise<T[K]>
  ): AsyncContextProvider<T> {
    this.providers.set(key, provider)
    return this
  }
  
  build(): ContextMiddleware<Context & T> {
    return async (context, next) => {
      const promises = Array.from(this.providers.entries()).map(
        async ([key, provider]) => {
          context[key] = await provider()
        }
      )
      
      await Promise.all(promises)
      await next()
    }
  }
}

// Usage
const contextProvider = new AsyncContextProvider<{
  db: Database
  cache: Cache
  auth: AuthService
}>()
  .provide('db', () => createDatabaseConnection())
  .provide('cache', () => createRedisClient())
  .provide('auth', () => createAuthService())

app.use(contextProvider.build())
```

## Testing Strategy

### Context Testing
```typescript
describe('Context System', () => {
  test('context injection', async () => {
    const app = new BunServe()
    
    app.use(async (ctx, next) => {
      ctx.testValue = 'injected'
      await next()
    })
    
    app.get('/test', {
      handler: (ctx) => ctx.testValue
    })
    
    const response = await app.fetch(new Request('http://localhost/test'))
    expect(await response.text()).toBe('injected')
  })
  
  test('type-safe context access', async () => {
    const app = new BunServe<{ db: { query: () => Promise<string[]> } }>()
    
    app.use(async (ctx, next) => {
      ctx.db = { query: async () => ['test'] }
      await next()
    })
    
    app.get('/data', {
      handler: async (ctx) => {
        // TypeScript knows ctx.db.query exists
        return await ctx.db.query()
      }
    })
    
    const response = await app.fetch(new Request('http://localhost/data'))
    expect(await response.json()).toEqual(['test'])
  })
})
```

### Context Validation Tests
```typescript
describe('Context Validation', () => {
  test('validates required context properties', () => {
    const validator = createContextValidator<{ user: User }>()
    
    const validContext = { user: { id: '1', name: 'John' } }
    expect(validator.validate(validContext)).toBe(true)
    
    const invalidContext = { user: null }
    expect(validator.validate(invalidContext)).toBe(false)
  })
})
```

## Error Handling

### Context Validation Errors
```typescript
// Missing context property
app.get('/protected', {
  handler: (ctx: Context<{ user: User }>) => {
    // If user is not provided, TypeScript error at compile time
    return ctx.user
  }
})

// Runtime context validation
app.use(async (ctx, next) => {
  if (!ctx.user) {
    throw new Error('User context required')
  }
  await next()
})
```

### Async Context Errors
```typescript
// Context provider error handling
app.use(async (ctx, next) => {
  try {
    ctx.db = await connectToDatabase()
    await next()
  } catch (error) {
    ctx.set.status = 503
    return { error: 'Database connection failed' }
  }
})
```

## Performance Considerations

### Context Building Optimization
- Lazy context initialization
- Context property caching
- Minimal object creation
- Efficient middleware chaining

### Memory Management
- Context objects are request-scoped
- Automatic cleanup after response
- No memory leaks from context references

## Documentation

### API Reference
- Context interface definitions
- Context middleware patterns
- Context validation
- Async context providers

### Examples
- Database connection context
- User authentication context
- Configuration management
- Service injection patterns

## Success Criteria

### Functional Requirements
- [ ] Generic context system
- [ ] Context augmentation through middleware
- [ ] Type-safe context access
- [ ] Async context building
- [ ] Context validation
- [ ] Error handling patterns

### Type Safety Requirements
- [ ] Full TypeScript context inference
- [ ] No runtime context property access errors
- [ ] Editor autocompletion for context properties
- [ ] Type-safe middleware composition

### Performance Requirements
- [ ] <0.5ms context building time
- [ ] No memory leaks from context objects
- [ ] Minimal overhead for simple routes

## Next Steps

This increment establishes a powerful context system. The next phase (2.1) will focus on implementing the core middleware system with support for before/after hooks and error propagation.