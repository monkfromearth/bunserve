# Increment 0.1: Router-based API

## Overview
This increment implements the foundational router-based API for BunServe, following Express-like patterns rather than the Elysia-style schema validation approach. The focus is on simple, flexible route definitions with factory functions.

## Objectives
- Create router-based architecture using factory functions
- Implement basic route parameter extraction
- Provide simple response helpers
- Enable Express-like route definitions
- Support all HTTP methods

## API Design

### Factory Function Pattern
```typescript
import { createRouter, createServer } from 'bunserve'

// Create router instance
const router = createRouter()

// Define routes with simple handlers
router.get('/hello', ({ set }) => {
  set.content = 'text'
  return 'Hello World!'
})

router.get('/users/:id', ({ params }) => {
  return { 
    id: params.id, 
    name: 'John Doe',
    email: 'john@example.com'
  }
})

router.post('/users', async ({ body }) => {
  const user = await createUser(body)
  return { success: true, user }
})

// Create server with router
const server = createServer({ router })
server.listen(3000)
```

### Route Handler Context
```typescript
interface RouteContext<TPath extends string> {
  request: Request           // Original Request object
  params: RouteParams<TPath> // URL parameters (/users/:id)
  query: Record<string, string> // Query parameters (?name=value)
  body: any                 // Parsed request body
  set: ResponseSetter        // Response configuration object
}

// Basic usage
router.get('/users/:id', ({ params, query, set }) => {
  // params.id is inferred as string
  // query is Record<string, string>
  // set controls response configuration
  return { id: params.id }
})
```

### Response Setter Interface
```typescript
interface ResponseSetter {
  status: number               // HTTP status code (default: 200)
  content: string             // Response content type
  headers: Record<string, string> // Custom headers
  redirect?: string           // Redirect URL
  cache?: string              // Cache duration ('1h', '30d')
}

// Content type options
type ContentType = 
  | 'json'    // JSON response (default)
  | 'text'    // Plain text
  | 'html'    // HTML response
  | 'xml'     // XML response

// Usage examples
router.get('/api/data', () => ({ success: true }))

router.get('/api/text', ({ set }) => {
  set.content = 'text'
  return 'Hello, World!'
})

router.get('/api/html', ({ set }) => {
  set.content = 'html'
  return '<h1>Hello, World!</h1>'
})
```

## Implementation Details

### Router Class
```typescript
class Router {
  private routes: Route[] = []
  
  // HTTP methods
  get<Path extends string>(path: Path, handler: RouteHandler<Path>): void
  post<Path extends string>(path: Path, handler: RouteHandler<Path>): void
  put<Path extends string>(path: Path, handler: RouteHandler<Path>): void
  patch<Path extends string>(path: Path, handler: RouteHandler<Path>): void
  delete<Path extends string>(path: Path, handler: RouteHandler<Path>): void
  options<Path extends string>(path: Path, handler: RouteHandler<Path>): void
  head<Path extends string>(path: Path, handler: RouteHandler<Path>): void
  
  // Add route implementation
  private addRoute<Path extends string>(
    method: HttpMethod,
    path: Path,
    handler: RouteHandler<Path>
  ): void {
    const { pattern, paramNames } = parseRoutePattern(path)
    this.routes.push({
      method,
      path,
      handler,
      pattern,
      paramNames
    })
  }
  
  // Route matching
  find(method: string, pathname: string): RouteMatch | null {
    for (const route of this.routes) {
      if (route.method !== method) continue
      
      const match = route.pattern.exec(pathname)
      if (match) {
        const params = this.extractParams(route.paramNames, match)
        return { route, params }
      }
    }
    return null
  }
}
```

### Parameter Extraction
```typescript
// Parse route pattern and extract parameters
function parseRoutePattern(path: string): {
  pattern: RegExp
  paramNames: string[]
} {
  const paramNames: string[] = []
  let patternStr = path
  
  // Convert :param to regex groups
  patternStr = patternStr.replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName)
    return '([^/]+)'
  })
  
  // Convert wildcard * to regex
  patternStr = patternStr.replace(/\*/g, '.*')
  
  return {
    pattern: new RegExp(`^${patternStr}$`),
    paramNames
  }
}

// Extract parameters from regex match
function extractParams(paramNames: string[], match: RegExpMatchArray): Record<string, string> {
  const params: Record<string, string> = {}
  
  for (let i = 0; i < paramNames.length; i++) {
    params[paramNames[i]] = match[i + 1]
  }
  
  return params
}
```

### Request Processing
```typescript
async function processRequest(request: Request, router: Router): Promise<Response> {
  const url = new URL(request.url)
  const method = request.method
  const pathname = url.pathname
  
  // Find matching route
  const routeMatch = router.find(method, pathname)
  
  if (!routeMatch) {
    return new Response('Not Found', { status: 404 })
  }
  
  // Parse query parameters
  const query = Object.fromEntries(url.searchParams)
  
  // Parse request body for non-GET requests
  let body = null
  if (method !== 'GET' && method !== 'HEAD') {
    const contentType = request.headers.get('content-type') || ''
    body = await parseRequestBody(request, contentType)
  }
  
  // Create response setter
  const set = new ResponseSetter()
  
  // Execute route handler
  const context: RouteContext<string> = {
    request,
    params: routeMatch.params,
    query,
    body,
    set
  }
  
  const result = await routeMatch.route.handler(context)
  
  // Build response
  return buildResponse(result, set)
}
```

### Response Builder
```typescript
function buildResponse(result: any, set: ResponseSetter): Response {
  let body: string | ArrayBuffer = ''
  let contentType = 'application/json'
  
  // Handle different content types
  switch (set.content) {
    case 'json':
      body = JSON.stringify(result)
      contentType = 'application/json'
      break
      
    case 'text':
      body = String(result)
      contentType = 'text/plain'
      break
      
    case 'html':
      body = String(result)
      contentType = 'text/html'
      break
      
    case 'xml':
      body = String(result)
      contentType = 'application/xml'
      break
  }
  
  // Build headers
  const headers: Record<string, string> = {
    'Content-Type': contentType,
    ...set.headers
  }
  
  // Add cache headers if specified
  if (set.cache) {
    headers['Cache-Control'] = `public, max-age=${parseCacheDuration(set.cache)}`
  }
  
  // Handle redirects
  if (set.redirect) {
    return Response.redirect(set.redirect, set.status || 302)
  }
  
  return new Response(body, {
    status: set.status || 200,
    headers
  })
}
```

### TypeScript Types
```typescript
// Route parameter type inference
type RouteParams<T extends string> = 
  T extends `${string}:${infer Param}/${infer Rest}`
    ? { [K in Param | keyof RouteParams<Rest>]: string }
    : T extends `${string}:${infer Param}`
      ? { [K in Param]: string }
      : {}

// Route handler type
type RouteHandler<TPath extends string> = (
  context: RouteContext<TPath>
) => Promise<any> | any

// HTTP methods
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD'

// Response setter class
class ResponseSetter {
  status: number = 200
  content: string = 'json'
  headers: Record<string, string> = {}
  redirect?: string
  cache?: string
}
```

## Testing Strategy

### Unit Tests
```typescript
describe('Router', () => {
  test('registers and matches routes', () => {
    const router = createRouter()
    router.get('/users/:id', ({ params }) => ({ id: params.id }))
    
    const match = router.find('GET', '/users/123')
    expect(match).toBeDefined()
    expect(match?.params.id).toBe('123')
  })
  
  test('extracts multiple parameters', () => {
    const router = createRouter()
    router.get('/users/:userId/posts/:postId', ({ params }) => params)
    
    const match = router.find('GET', '/users/123/posts/456')
    expect(match?.params).toEqual({
      userId: '123',
      postId: '456'
    })
  })
})

describe('Response Builder', () => {
  test('builds JSON response', () => {
    const set = new ResponseSetter()
    const response = buildResponse({ message: 'Hello' }, set)
    
    expect(response.status).toBe(200)
    expect(response.headers.get('Content-Type')).toBe('application/json')
  })
  
  test('builds text response', () => {
    const set = new ResponseSetter()
    set.content = 'text'
    const response = buildResponse('Hello World', set)
    
    expect(response.headers.get('Content-Type')).toBe('text/plain')
  })
})
```

### Integration Tests
```typescript
describe('Full Request Cycle', () => {
  test('handles GET request with parameters', async () => {
    const router = createRouter()
    router.get('/users/:id', ({ params }) => ({ id: params.id }))
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/users/123'))
    
    expect(response.status).toBe(200)
    const data = await response.json()
    expect(data.id).toBe('123')
  })
  
  test('handles POST request with JSON body', async () => {
    const router = createRouter()
    router.post('/users', ({ body }) => ({ received: body }))
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'John' })
    }))
    
    expect(response.status).toBe(200)
    const data = await response.json()
    expect(data.received.name).toBe('John')
  })
})
```

## Error Handling

### Route Not Found
```typescript
// Automatic 404 for unmatched routes
router.get('/existing', () => 'exists')
// GET /non-existing returns 404
```

### Handler Errors
```typescript
// Basic error handling
router.get('/error', () => {
  throw new Error('Something went wrong')
  // Returns 500 with error message
})
```

## Performance Considerations

### Route Matching Optimization
- Pre-compile route patterns during registration
- Linear search (optimized in future increments)
- Efficient regex matching

### Memory Usage
- Minimal object creation per request
- Reuse response setter instances
- Efficient parameter extraction

## Documentation

### API Reference
- `createRouter()` factory function
- Router methods (get, post, put, delete, etc.)
- RouteContext interface
- ResponseSetter interface

### Examples
- Basic "Hello World" server
- Simple JSON API
- Parameterized routes
- Different response types

## Success Criteria

### Functional Requirements
- [ ] Router-based API with factory functions
- [ ] All HTTP method support
- [ ] URL parameter extraction
- [ ] Query parameter parsing
- [ ] Basic response helpers
- [ ] Error handling

### Type Safety Requirements
- [ ] Route parameter type inference
- [ ] Handler context type safety
- [ ] Optional type annotations
- [ ] No runtime type errors

### Performance Requirements
- [ ] <1ms route matching time
- [ ] Minimal memory overhead
- [ ] No performance regression vs raw Bun.serve

## Next Steps

This increment establishes the Express-like foundation. The next increment (0.2) will focus on enhanced response helpers, body parsing, and `@theinternetfolks/context` integration for request-scoped data sharing.