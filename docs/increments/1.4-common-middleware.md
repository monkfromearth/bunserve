# Increment 1.4: Common Middleware & Helpers

## Overview
This increment provides essential middleware and helper functions out of the box, reducing boilerplate code and accelerating development. These built-in utilities cover common web development needs like CORS, static file serving, body parsing, and security headers.

## Objectives
- Implement CORS middleware with flexible configuration
- Add static file serving with directory listing
- Provide enhanced body parsing utilities
- Add security headers middleware
- Include common validation helpers

## API Design

### Built-in Middleware Import
```typescript
import { 
  createRouter, 
  createServer,
  cors,
  staticFiles,
  securityHeaders,
  bodyparser,
  validateQuery,
  validateParams
} from 'bunserve/middleware'

const router = createRouter()

// Use built-in middleware
router.use(cors({
  origin: ['http://localhost:3000', 'https://myapp.com'],
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}))

router.use(securityHeaders())
router.use(bodyparser())

router.use(staticFiles({
  path: './public',
  index: 'index.html',
  maxAge: '1h'
}))
```

### CORS Middleware
```typescript
import { cors } from 'bunserve/middleware'

// Simple CORS
router.use(cors())

// Advanced CORS configuration
router.use(cors({
  origin: (origin) => {
    // Allow specific origins
    const allowedOrigins = [
      'http://localhost:3000',
      'https://myapp.com',
      'https://admin.myapp.com'
    ]
    return allowedOrigins.includes(origin) ? origin : false
  },
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  exposedHeaders: ['X-Total-Count', 'X-Request-ID'],
  credentials: true,
  maxAge: 86400 // 24 hours
}))

// Environment-specific CORS
const corsConfig = process.env.NODE_ENV === 'production' 
  ? {
      origin: ['https://myapp.com'],
      credentials: true
    }
  : {
      origin: '*',
      credentials: false
    }

router.use(cors(corsConfig))
```

### Static File Serving
```typescript
import { staticFiles } from 'bunserve/middleware'

// Basic static file serving
router.use(staticFiles('./public'))

// Advanced configuration
router.use(staticFiles({
  path: './public',
  index: 'index.html', // Default file
  maxAge: '1h',       // Cache duration
  etag: true,         // Enable ETag generation
  lastModified: true,  // Enable Last-Modified headers
  dotfiles: 'ignore', // How to handle dotfiles: 'ignore', 'allow', 'deny'
  fallthrough: false, // Don't fall through to next middleware
  extensions: ['html', 'htm'], // Try these extensions if file not found
  setHeaders: (res, path) => {
    // Custom headers based on file type
    if (path.endsWith('.html')) {
      res.setHeader('Content-Security-Policy', "default-src 'self'")
    }
  }
}))

// Multiple static directories
router.use('/assets', staticFiles('./dist/assets'))
router.use('/uploads', staticFiles('./uploads', {
  maxAge: '30d',
  setHeaders: (res, path) => {
    res.setHeader('X-Content-Type-Options', 'nosniff')
  }
}))

// Static files with authentication
router.use('/private/*', 
  [requireAuth], 
  staticFiles('./private', {
    index: false // Disable directory listing
  })
)
```

### Security Headers Middleware
```typescript
import { securityHeaders } from 'bunserve/middleware'

// Basic security headers
router.use(securityHeaders())

// Custom security configuration
router.use(securityHeaders({
  contentSecurityPolicy: {
    defaultSrc: ["'self'"],
    styleSrc: ["'self'", "'unsafe-inline'"],
    scriptSrc: ["'self'"],
    imgSrc: ["'self'", "data:", "https:"],
    connectSrc: ["'self'"],
    fontSrc: ["'self'"],
    objectSrc: ["'none'"],
    mediaSrc: ["'self'"],
    frameSrc: ["'none'"]
  },
  hsts: {
    maxAge: 31536000, // 1 year
    includeSubDomains: true,
    preload: true
  },
  xssProtection: '1; mode=block',
  noSniff: true,
  referrerPolicy: 'strict-origin-when-cross-origin',
  permissionsPolicy: {
    camera: '()',
    microphone: '()',
    geolocation: '()',
    payment: '()'
  }
}))

// Development vs production security
const securityConfig = process.env.NODE_ENV === 'production'
  ? {
      contentSecurityPolicy: { defaultSrc: ["'self'"] },
      hsts: { maxAge: 31536000, includeSubDomains: true }
    }
  : {
      contentSecurityPolicy: { 
        defaultSrc: ["'self'", "localhost:*"],
        scriptSrc: ["'self'", "'unsafe-inline'", "localhost:*"]
      }
    }

router.use(securityHeaders(securityConfig))
```

### Enhanced Body Parsing
```typescript
import { bodyparser } from 'bunserve/middleware'

// Basic body parsing
router.use(bodyparser())

// Advanced body parsing configuration
router.use(bodyparser({
  json: {
    limit: '10mb',
    strict: true,  // Only accept objects and arrays
    type: 'application/json'
  },
  urlencoded: {
    extended: true,  // Allow rich objects and arrays
    limit: '10mb',
    parameterLimit: 1000
  },
  text: {
    limit: '1mb',
    type: 'text/plain'
  },
  raw: {
    limit: '5mb',
    type: 'application/octet-stream'
  },
  multipart: false // Disable multipart (use specialized middleware)
}))

// Content-type specific body parsing
router.use(bodyparser({
  json: { limit: '1mb' },
  text: false // Disable text parsing
}))

// Custom body parser middleware
const customBodyParser = async ({ request, set }, next) => {
  const contentType = request.headers.get('content-type') || ''
  
  if (contentType.includes('application/json')) {
    try {
      const text = await request.text()
      request.body = JSON.parse(text)
    } catch (error) {
      set.status = 400
      return { error: 'Invalid JSON' }
    }
  } else if (contentType.includes('application/x-www-form-urlencoded')) {
    const formData = await request.formData()
    request.body = Object.fromEntries(formData)
  }
  
  return next()
}
```

### Validation Helpers
```typescript
import { validateQuery, validateParams } from 'bunserve/middleware'

// Query parameter validation
router.get('/api/users',
  validateQuery({
    page: { type: 'number', default: 1, min: 1 },
    limit: { type: 'number', default: 10, min: 1, max: 100 },
    search: { type: 'string', optional: true }
  }),
  ({ query }) => {
    const { page, limit, search } = query
    return getUsers(page, limit, search)
  }
)

// Route parameter validation
router.get('/api/users/:id',
  validateParams({
    id: { type: 'string', pattern: /^[0-9a-f]{24}$/ } // MongoDB ObjectId
  }),
  ({ params }) => {
    return getUserById(params.id)
  }
)

// Custom validation rules
router.post('/api/users',
  validateBody({
    email: { 
      type: 'string', 
      required: true,
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    },
    password: { 
      type: 'string', 
      required: true,
      minLength: 8,
      validate: (value) => {
        if (!/[A-Z]/.test(value)) {
          throw new Error('Password must contain uppercase letter')
        }
        if (!/[0-9]/.test(value)) {
          throw new Error('Password must contain number')
        }
      }
    },
    age: { 
      type: 'number', 
      optional: true,
      min: 18,
      max: 120
    }
  }),
  ({ body }) => {
    return createUser(body)
  }
)
```

### Common Helper Functions
```typescript
import { 
  createRouter,
  requireAuth,
  requireRole,
  rateLimit,
  cacheControl
} from 'bunserve/helpers'

const router = createRouter()

// Authentication helper
router.get('/api/profile', 
  requireAuth(), 
  ({ request }) => {
    const user = Context.get('user')
    return user
  }
)

// Role-based authorization
router.get('/api/admin', 
  [requireAuth(), requireRole('admin')], 
  () => {
    return { admin: true }
  }
)

// Rate limiting
router.post('/api/contact',
  rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // Limit each IP to 5 requests per windowMs
    message: 'Too many contact requests, please try again later'
  }),
  ({ body }) => {
    return sendContactEmail(body)
  }
)

// Cache control
router.get('/api/data',
  cacheControl('1h'), // Cache for 1 hour
  () => {
    return getExpensiveData()
  }
)

// Request ID helper
router.use(({}, next) => {
  Context.init()
  Context.set({
    requestId: generateUUID(),
    startTime: Date.now()
  })
  return next()
})

// Response time helper
router.use(async ({}, next) => {
  const start = Date.now()
  const result = await next()
  
  const duration = Date.now() - start
  Context.get().responseTime = duration
  
  return result
})
```

## Implementation Details

### CORS Middleware Implementation
```typescript
interface CorsOptions {
  origin?: string | string[] | ((origin: string) => string | boolean)
  methods?: string[]
  allowedHeaders?: string[]
  exposedHeaders?: string[]
  credentials?: boolean
  maxAge?: number
}

function cors(options: CorsOptions = {}): Middleware {
  const defaults = {
    origin: '*',
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE'],
    allowedHeaders: [],
    exposedHeaders: [],
    credentials: false,
    maxAge: 86400
  }
  
  const config = { ...defaults, ...options }
  
  return async ({ request, set }, next) => {
    const origin = request.headers.get('origin') || ''
    
    // Handle preflight requests
    if (request.method === 'OPTIONS') {
      set.headers = {
        ...set.headers,
        'Access-Control-Allow-Methods': config.methods.join(','),
        'Access-Control-Allow-Headers': config.allowedHeaders.join(','),
        'Access-Control-Max-Age': String(config.maxAge)
      }
      
      // Set origin based on configuration
      if (typeof config.origin === 'function') {
        const allowedOrigin = config.origin(origin)
        if (allowedOrigin) {
          set.headers['Access-Control-Allow-Origin'] = allowedOrigin
        }
      } else if (Array.isArray(config.origin)) {
        if (config.origin.includes(origin)) {
          set.headers['Access-Control-Allow-Origin'] = origin
        }
      } else {
        set.headers['Access-Control-Allow-Origin'] = config.origin
      }
      
      if (config.credentials) {
        set.headers['Access-Control-Allow-Credentials'] = 'true'
      }
      
      set.status = 204
      return null
    }
    
    // Handle actual requests
    const result = await next()
    
    // Add CORS headers to response
    if (typeof config.origin === 'function') {
      const allowedOrigin = config.origin(origin)
      if (allowedOrigin) {
        set.headers['Access-Control-Allow-Origin'] = allowedOrigin
      }
    } else if (Array.isArray(config.origin)) {
      if (config.origin.includes(origin)) {
        set.headers['Access-Control-Allow-Origin'] = origin
      }
    } else {
      set.headers['Access-Control-Allow-Origin'] = config.origin
    }
    
    if (config.credentials) {
      set.headers['Access-Control-Allow-Credentials'] = 'true'
    }
    
    if (config.exposedHeaders.length > 0) {
      set.headers['Access-Control-Expose-Headers'] = config.exposedHeaders.join(',')
    }
    
    return result
  }
}
```

### Static Files Middleware Implementation
```typescript
interface StaticFilesOptions {
  path: string
  index?: string | false
  maxAge?: string | number
  etag?: boolean
  lastModified?: boolean
  dotfiles?: 'ignore' | 'allow' | 'deny'
  fallthrough?: boolean
  extensions?: string[]
  setHeaders?: (res: Response, path: string) => void
}

function staticFiles(rootPath: string, options: StaticFilesOptions = {}): Middleware {
  const config = {
    index: 'index.html',
    maxAge: 0,
    etag: true,
    lastModified: true,
    dotfiles: 'ignore',
    fallthrough: true,
    extensions: [],
    ...options,
    path: rootPath
  }
  
  return async ({ request, set }, next) => {
    const url = new URL(request.url)
    const pathname = decodeURIComponent(url.pathname)
    
    // Resolve file path
    let filePath = path.join(config.path, pathname)
    
    // Try extensions if file not found
    if (config.extensions.length > 0 && !(await Bun.file(filePath).exists())) {
      for (const ext of config.extensions) {
        const extendedPath = filePath + ext
        if (await Bun.file(extendedPath).exists()) {
          filePath = extendedPath
          break
        }
      }
    }
    
    // Handle directory index
    const stat = await Bun.file(filePath).stat()
    if (stat?.isDirectory) {
      if (config.index) {
        filePath = path.join(filePath, config.index)
      } else {
        return next() // Fall through to next middleware
      }
    }
    
    // Check if file exists
    if (!(await Bun.file(filePath).exists())) {
      if (config.fallthrough) {
        return next()
      }
      set.status = 404
      return { error: 'File not found' }
    }
    
    // Handle dotfiles
    const fileName = path.basename(filePath)
    if (fileName.startsWith('.') && config.dotfiles === 'deny') {
      set.status = 403
      return { error: 'Forbidden' }
    }
    
    // Set cache headers
    if (config.maxAge) {
      const maxAge = typeof config.maxAge === 'string' 
        ? parseCacheDuration(config.maxAge)
        : config.maxAge
      set.headers['Cache-Control'] = `public, max-age=${maxAge}`
    }
    
    // Set ETag
    if (config.etag) {
      const fileContent = await Bun.file(filePath).arrayBuffer()
      const etag = generateETag(fileContent)
      set.headers['ETag'] = etag
      
      // Check If-None-Match header
      const ifNoneMatch = request.headers.get('if-none-match')
      if (ifNoneMatch === etag) {
        set.status = 304
        return null
      }
    }
    
    // Set Last-Modified
    if (config.lastModified) {
      const mtime = stat?.mtime
      if (mtime) {
        const lastModified = new Date(mtime).toUTCString()
        set.headers['Last-Modified'] = lastModified
        
        // Check If-Modified-Since header
        const ifModifiedSince = request.headers.get('if-modified-since')
        if (ifModifiedSince === lastModified) {
          set.status = 304
          return null
        }
      }
    }
    
    // Custom headers
    if (config.setHeaders) {
      config.setHeaders({ headers: set.headers } as Response, filePath)
    }
    
    // Set content type
    const ext = path.extname(filePath).toLowerCase()
    set.headers['Content-Type'] = getMimeType(ext)
    
    return Bun.file(filePath)
  }
}
```

### Validation Helpers Implementation
```typescript
interface ValidationRule {
  type: 'string' | 'number' | 'boolean' | 'array' | 'object'
  required?: boolean
  optional?: boolean
  default?: any
  min?: number
  max?: number
  minLength?: number
  maxLength?: number
  pattern?: RegExp
  validate?: (value: any) => void | Promise<void>
}

function validateQuery(rules: Record<string, ValidationRule>): Middleware {
  return async ({ request, set }, next) => {
    const url = new URL(request.url)
    const query = Object.fromEntries(url.searchParams)
    const validated: Record<string, any> = {}
    
    for (const [field, rule] of Object.entries(rules)) {
      let value = query[field]
      
      // Handle default values
      if (value === undefined || value === '') {
        if (rule.default !== undefined) {
          value = rule.default
        } else if (rule.required) {
          set.status = 400
          return { error: `Query parameter '${field}' is required` }
        } else if (rule.optional) {
          continue
        }
      }
      
      // Type conversion and validation
      try {
        validated[field] = validateValue(value, rule)
      } catch (error) {
        set.status = 400
        return { error: `Invalid query parameter '${field}': ${error.message}` }
      }
    }
    
    // Replace query with validated values
    request.query = validated
    
    return next()
  }
}

function validateValue(value: any, rule: ValidationRule): any {
  // Type conversion
  switch (rule.type) {
    case 'number':
      value = Number(value)
      if (isNaN(value)) {
        throw new Error('Must be a number')
      }
      break
    case 'boolean':
      value = value === 'true' || value === '1'
      break
    case 'array':
      if (typeof value === 'string') {
        value = value.split(',').map(v => v.trim())
      }
      if (!Array.isArray(value)) {
        throw new Error('Must be an array')
      }
      break
  }
  
  // Required validation
  if (rule.required && (value === undefined || value === null || value === '')) {
    throw new Error('Is required')
  }
  
  // Skip further validation for optional empty values
  if (rule.optional && (value === undefined || value === null || value === '')) {
    return value
  }
  
  // Type-specific validation
  switch (rule.type) {
    case 'string':
      if (typeof value !== 'string') {
        throw new Error('Must be a string')
      }
      if (rule.minLength && value.length < rule.minLength) {
        throw new Error(`Must be at least ${rule.minLength} characters`)
      }
      if (rule.maxLength && value.length > rule.maxLength) {
        throw new Error(`Must be at most ${rule.maxLength} characters`)
      }
      if (rule.pattern && !rule.pattern.test(value)) {
        throw new Error('Format is invalid')
      }
      break
      
    case 'number':
      if (typeof value !== 'number') {
        throw new Error('Must be a number')
      }
      if (rule.min !== undefined && value < rule.min) {
        throw new Error(`Must be at least ${rule.min}`)
      }
      if (rule.max !== undefined && value > rule.max) {
        throw new Error(`Must be at most ${rule.max}`)
      }
      break
  }
  
  // Custom validation
  if (rule.validate) {
    rule.validate(value)
  }
  
  return value
}
```

## Testing Strategy

### Middleware Tests
```typescript
describe('Built-in Middleware', () => {
  test('CORS middleware handles preflight requests', async () => {
    const router = createRouter()
    router.use(cors())
    router.get('/test', () => 'test')
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/test', {
      method: 'OPTIONS'
    }))
    
    expect(response.status).toBe(204)
    expect(response.headers.get('Access-Control-Allow-Methods')).toContain('GET')
  })
  
  test('Static files middleware serves files', async () => {
    const router = createRouter()
    router.use('/static', staticFiles('./test/fixtures'))
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/static/test.txt'))
    
    expect(response.status).toBe(200)
    expect(await response.text()).toBe('test content')
  })
})
```

### Validation Tests
```typescript
describe('Validation Helpers', () => {
  test('validates query parameters', async () => {
    const router = createRouter()
    router.get('/test',
      validateQuery({
        page: { type: 'number', default: 1 },
        limit: { type: 'number', min: 1, max: 100 }
      }),
      ({ query }) => ({ page: query.page, limit: query.limit })
    )
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/test?limit=50'))
    
    expect(response.status).toBe(200)
    const data = await response.json()
    expect(data.page).toBe(1)
    expect(data.limit).toBe(50)
  })
  
  test('rejects invalid parameters', async () => {
    const router = createRouter()
    router.get('/test',
      validateQuery({
        age: { type: 'number', min: 18 }
      }),
      () => 'test'
    )
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/test?age=15'))
    
    expect(response.status).toBe(400)
    const data = await response.json()
    expect(data.error).toContain('age')
  })
})
```

## Performance Considerations

### Middleware Optimization
- Lazy loading of static files
- Efficient ETag generation
- Cached validation rules
- Minimal overhead for disabled features

### Memory Management
- Efficient file streaming
- Cached MIME type lookups
- Memory-efficient validation
- Garbage collection friendly

## Documentation

### Middleware Reference
- CORS configuration options
- Static file serving features
- Security headers documentation
- Body parsing options
- Validation rule types

### Helper Functions
- Authentication helpers
- Authorization helpers
- Rate limiting configuration
- Cache control options

## Success Criteria

### Functional Requirements
- [ ] CORS middleware with flexible configuration
- [ ] Static file serving with caching
- [ ] Security headers middleware
- [ ] Enhanced body parsing
- [ ] Query/parameter validation helpers
- [ ] Common authentication helpers
- [ ] Rate limiting utilities

### Performance Requirements
- [ ] <5ms middleware overhead
- [ ] Efficient static file serving
- [ ] Fast validation processing
- [ ] Minimal memory usage

### Security Requirements
- [ ] Secure CORS configuration
- [ ] Comprehensive security headers
- [ ] Input validation
- [ ] Safe file serving

## Next Steps

This increment provides essential middleware and helpers out of the box. The next increment (1.5) will focus on production optimization features like compression, advanced monitoring, and deployment utilities.