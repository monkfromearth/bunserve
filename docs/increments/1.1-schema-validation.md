# Increment 1.1: Route Schema Validation

## Overview
This increment introduces robust schema validation for route parameters, query strings, request bodies, and responses. It leverages TypeScript for compile-time type checking and runtime validation to ensure data integrity.

## Objectives
- Implement schema validation system
- Add compile-time type inference
- Provide runtime validation errors
- Support validation for params, query, body, and response
- Integrate with existing route system

## API Design

### Schema-based Route Definition
```typescript
import { BunServe, t } from 'bunserve'

const app = new BunServe()

// Define schemas
const UserSchema = t.Object({
  id: t.String(),
  name: t.String(),
  email: t.String(),
  age: t.Optional(t.Number())
})

const CreateUserSchema = t.Object({
  name: t.String(),
  email: t.String(),
  age: t.Optional(t.Number({ minimum: 0, maximum: 120 }))
})

// Route with full schema validation
app.post('/users', {
  schema: {
    body: CreateUserSchema,
    response: UserSchema
  },
  handler: async ({ body }) => {
    // body is fully typed and validated
    const user = await createUser(body)
    return user
  }
})

// Route with parameter validation
app.get('/users/:id', {
  schema: {
    params: t.Object({
      id: t.String({ format: 'uuid' })
    }),
    query: t.Object({
      include: t.Optional(t.Enum(['profile', 'stats']))
    }),
    response: UserSchema
  },
  handler: ({ params, query }) => {
    // params.id and query.include are validated
    return getUserById(params.id, query.include)
  }
})
```

### Type-safe Inference
```typescript
// Automatic type inference from schemas
app.post('/users', {
  schema: {
    body: t.Object({
      name: t.String(),
      email: t.String()
    }),
    response: t.Object({
      id: t.String(),
      name: t.String(),
      email: t.String()
    })
  },
  handler: ({ body }) => {
    // TypeScript knows body.name and body.email are strings
    return {
      id: generateId(),
      name: body.name,
      email: body.email
    }
  }
})
```

## Implementation Details

### Schema Validation System
```typescript
// TypeBox-inspired schema system
type Schema = 
  | { type: 'string'; format?: string; minLength?: number; maxLength?: number }
  | { type: 'number'; minimum?: number; maximum?: number }
  | { type: 'boolean' }
  | { type: 'object'; properties: Record<string, Schema>; required?: string[] }
  | { type: 'array'; items: Schema }
  | { type: 'enum'; values: string[] }

class SchemaValidator {
  validate(value: any, schema: Schema): ValidationResult {
    try {
      this.validateRecursive(value, schema)
      return { success: true, value }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }
  
  private validateRecursive(value: any, schema: Schema): void {
    switch (schema.type) {
      case 'string':
        if (typeof value !== 'string') {
          throw new Error(`Expected string, got ${typeof value}`)
        }
        if (schema.format && !this.validateFormat(value, schema.format)) {
          throw new Error(`Invalid format: ${schema.format}`)
        }
        break
        
      case 'number':
        if (typeof value !== 'number') {
          throw new Error(`Expected number, got ${typeof value}`)
        }
        if (schema.minimum !== undefined && value < schema.minimum) {
          throw new Error(`Value must be >= ${schema.minimum}`)
        }
        break
        
      // ... other type validations
    }
  }
}
```

### Route Schema Integration
```typescript
interface RouteSchema {
  params?: Schema
  query?: Schema
  body?: Schema
  response?: Schema
}

interface ValidatedRoute<TPath extends string, TSchema extends RouteSchema> {
  schema: TSchema
  handler: SchemaRouteHandler<TPath, TSchema>
}

type SchemaRouteHandler<TPath extends string, TSchema extends RouteSchema> = (
  context: SchemaRequestContext<TPath, TSchema>
) => Promise<InferResponse<TSchema>> | InferResponse<TSchema>

interface SchemaRequestContext<TPath extends string, TSchema extends RouteSchema> {
  request: Request
  params: InferParams<TPath, TSchema>
  query: InferQuery<TSchema>
  body: InferBody<TSchema>
  set: ResponseSetter
}

// Type inference helpers
type InferParams<TPath extends string, TSchema extends RouteSchema> = 
  TSchema extends { params: infer P } ? InferSchema<P> : RouteParams<TPath>

type InferQuery<TSchema extends RouteSchema> = 
  TSchema extends { query: infer Q } ? InferSchema<Q> : Record<string, string>

type InferBody<TSchema extends RouteSchema> = 
  TSchema extends { body: infer B } ? InferSchema<B> : any

type InferResponse<TSchema extends RouteSchema> = 
  TSchema extends { response: infer R } ? InferSchema<R> : any
```

### Extended Route Processing
```typescript
async function processValidatedRoute(request: Request, route: ValidatedRoute): Promise<Response> {
  const url = new URL(request.url)
  const path = url.pathname
  
  // Validate parameters
  const params = extractParams(path, route)
  if (route.schema.params) {
    const paramsResult = validator.validate(params, route.schema.params)
    if (!paramsResult.success) {
      return new Response(JSON.stringify({
        error: 'Invalid parameters',
        details: paramsResult.error
      }), { status: 400 })
    }
  }
  
  // Validate query parameters
  const query = Object.fromEntries(url.searchParams)
  if (route.schema.query) {
    const queryResult = validator.validate(query, route.schema.query)
    if (!queryResult.success) {
      return new Response(JSON.stringify({
        error: 'Invalid query parameters',
        details: queryResult.error
      }), { status: 400 })
    }
  }
  
  // Validate body
  let body = null
  if (route.schema.body && request.method !== 'GET') {
    const contentType = request.headers.get('content-type') || ''
    body = await parseBody(request, contentType)
    
    const bodyResult = validator.validate(body, route.schema.body)
    if (!bodyResult.success) {
      return new Response(JSON.stringify({
        error: 'Invalid request body',
        details: bodyResult.error
      }), { status: 400 })
    }
  }
  
  // Execute handler
  const context = {
    request,
    params: paramsResult?.value || params,
    query: queryResult?.value || query,
    body: bodyResult?.value || body,
    set: new ResponseSetter()
  }
  
  const result = await route.handler(context)
  
  // Validate response
  if (route.schema.response) {
    const responseResult = validator.validate(result, route.schema.response)
    if (!responseResult.success) {
      console.error('Response validation failed:', responseResult.error)
      // For development, include validation errors
      if (process.env.NODE_ENV === 'development') {
        return new Response(JSON.stringify({
          error: 'Internal server error',
          validationError: responseResult.error
        }), { status: 500 })
      }
      return new Response('Internal server error', { status: 500 })
    }
  }
  
  return buildResponse(result, context.set)
}
```

### Schema Builder API
```typescript
// TypeBox-like schema builder
const t = {
  // Primitive types
  String: (options?: StringOptions) => ({ type: 'string', ...options }),
  Number: (options?: NumberOptions) => ({ type: 'number', ...options }),
  Boolean: () => ({ type: 'boolean' }),
  
  // Complex types
  Object: <T extends Record<string, Schema>>(
    properties: T, 
    options?: ObjectOptions
  ) => ({ type: 'object', properties, ...options }),
  
  Array: <T extends Schema>(items: T) => ({ type: 'array', items }),
  
  Enum: <T extends string[]>(values: T) => ({ type: 'enum', values }),
  
  // Modifiers
  Optional: <T extends Schema>(schema: T) => ({ ...schema, optional: true }),
  
  // Formats
  UUID: () => ({ type: 'string', format: 'uuid' }),
  Email: () => ({ type: 'string', format: 'email' }),
  URL: () => ({ type: 'string', format: 'url' })
}

// Usage examples
const UserSchema = t.Object({
  id: t.String({ format: 'uuid' }),
  name: t.String({ minLength: 1, maxLength: 100 }),
  email: t.String({ format: 'email' }),
  age: t.Optional(t.Number({ minimum: 0, maximum: 120 }))
})
```

## Testing Strategy

### Schema Validation Tests
```typescript
describe('Schema Validation', () => {
  const validator = new SchemaValidator()
  
  test('validates string with format', () => {
    const schema = t.String({ format: 'email' })
    
    expect(validator.validate('test@example.com', schema).success).toBe(true)
    expect(validator.validate('invalid-email', schema).success).toBe(false)
  })
  
  test('validates object with required fields', () => {
    const schema = t.Object({
      name: t.String(),
      age: t.Number()
    })
    
    expect(validator.validate({ name: 'John', age: 30 }, schema).success).toBe(true)
    expect(validator.validate({ name: 'John' }, schema).success).toBe(false)
  })
  
  test('validates optional fields', () => {
    const schema = t.Object({
      name: t.String(),
      age: t.Optional(t.Number())
    })
    
    expect(validator.validate({ name: 'John' }, schema).success).toBe(true)
    expect(validator.validate({ name: 'John', age: 30 }, schema).success).toBe(true)
  })
})
```

### Route Integration Tests
```typescript
describe('Route Schema Integration', () => {
  test('validates request body', async () => {
    const app = new BunServe()
    
    app.post('/users', {
      schema: {
        body: t.Object({
          name: t.String({ minLength: 1 }),
          email: t.String({ format: 'email' })
        })
      },
      handler: ({ body }) => ({ success: true, user: body })
    })
    
    // Valid request
    const validResponse = await app.fetch(new Request('http://localhost/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: 'John', email: 'john@example.com' })
    }))
    expect(validResponse.status).toBe(200)
    
    // Invalid request
    const invalidResponse = await app.fetch(new Request('http://localhost/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: '', email: 'invalid' })
    }))
    expect(invalidResponse.status).toBe(400)
  })
  
  test('validates response in development', async () => {
    const originalEnv = process.env.NODE_ENV
    process.env.NODE_ENV = 'development'
    
    const app = new BunServe()
    
    app.get('/test', {
      schema: {
        response: t.Object({ message: t.String() })
      },
      handler: () => ({ wrong: 'response' }) // Invalid response
    })
    
    const response = await app.fetch(new Request('http://localhost/test'))
    expect(response.status).toBe(500)
    
    process.env.NODE_ENV = originalEnv
  })
})
```

## Error Handling

### Validation Error Format
```typescript
interface ValidationError {
  path: string
  message: string
  value: any
}

interface ValidationErrorResponse {
  error: string
  details: ValidationError[]
}
```

### Error Responses
```typescript
// Parameter validation error
{
  "error": "Invalid parameters",
  "details": [
    {
      "path": "id",
      "message": "Invalid UUID format",
      "value": "invalid-uuid"
    }
  ]
}

// Body validation error
{
  "error": "Invalid request body",
  "details": [
    {
      "path": "email",
      "message": "Invalid email format",
      "value": "invalid-email"
    }
  ]
}
```

## Performance Considerations

### Validation Optimization
- Compile-time schema compilation
- Lazy validation (only when needed)
- Cached validation results
- Efficient error message generation

### Memory Usage
- Schema objects are immutable
- Validation contexts are reused
- Minimal object creation during validation

## Documentation

### API Reference
- Schema builder functions
- Validation options
- Error formats
- Type inference patterns

### Examples
- User registration validation
- API input validation
- Response validation
- Custom validation rules

## Success Criteria

### Functional Requirements
- [ ] Parameter validation
- [ ] Query string validation
- [ ] Request body validation
- [ ] Response validation (development)
- [ ] Comprehensive error messages
- [ ] Type inference from schemas

### Type Safety Requirements
- [ ] Full compile-time type inference
- [ ] Schema-driven types
- [ ] No manual type annotations needed
- [ ] Editor autocompletion support

### Performance Requirements
- [ ] <1ms validation time for simple schemas
- [ ] <5ms validation time for complex schemas
- [ ] No validation overhead for routes without schemas

## Next Steps

This increment establishes a robust validation system. The next increment (1.2) will focus on enhancing type safety through context interfaces and middleware injection patterns.