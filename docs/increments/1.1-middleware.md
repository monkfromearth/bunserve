# Increment 1.1: Express-style Middleware

## Overview
This increment implements a comprehensive Express-style middleware system that enables authentication, logging, validation, and other cross-cutting concerns. The middleware system is fully compatible with Express patterns and integrates seamlessly with `@theinternetfolks/context`.

## Objectives
- Implement Express-compatible middleware API
- Support global and route-specific middleware
- Enable middleware chaining with `next()` function
- Provide error handling middleware
- Integrate with request-scoped context

## API Design

### Global Middleware
```typescript
import { createRouter, createServer } from 'bunserve'
import { Context } from '@theinternetfolks/context'

const router = createRouter()

// Request logging middleware
router.use(async ({ request }, next) => {
  const start = Date.now()
  const context = Context.get<{ requestId: string }>()
  
  console.log(`[${context.requestId}] ${request.method} ${request.url}`)
  
  await next()
  
  const duration = Date.now() - start
  console.log(`[${context.requestId}] Completed in ${duration}ms`)
})

// Authentication middleware
router.use(async ({ request, set }, next) => {
  const token = request.headers.get('authorization')
  
  if (!token) {
    set.status = 401
    return { error: 'Authorization token required' }
  }
  
  try {
    const user = await verifyToken(token)
    Context.set({ user }) // Store in context
    await next()
  } catch (error) {
    set.status = 401
    return { error: 'Invalid or expired token' }
  }
})

// CORS middleware
router.use(({ request, set }, next) => {
  set.headers = {
    ...set.headers,
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  }
  
  // Handle preflight requests
  if (request.method === 'OPTIONS') {
    set.status = 204
    return null
  }
  
  return next()
})
```

### Route-Specific Middleware
```typescript
// Single route with middleware array
router.post('/api/users',
  [validateUser, rateLimit], // Middleware chain
  async ({ body }) => {
    return await createUser(body)
  }
)

// Multiple middleware with different purposes
router.put('/api/users/:id',
  [
    authenticate,           // Check authentication
    authorize('admin'),    // Check admin permissions
    validateUserUpdate     // Validate input data
  ],
  async ({ params, body }) => {
    return await updateUser(params.id, body)
  }
)

// GET route with middleware
router.get('/api/admin/*',
  [requireAuth, requireAdmin],
  async () => {
    return { admin: true, data: 'sensitive' }
  }
)
```

### Middleware with Context Integration
```typescript
// Request ID middleware
router.use(({}, next) => {
  const requestId = generateId()
  Context.init()
  Context.set({
    requestId,
    startTime: Date.now(),
    ip: 'unknown' // Will be set by IP middleware
  })
  
  return next()
})

// IP extraction middleware
router.use(({ request }, next) => {
  const ip = request.headers.get('x-forwarded-for') || 
             request.headers.get('x-real-ip') || 
             'unknown'
  
  const context = Context.get()
  context.ip = ip
  
  return next()
})

// User context middleware
router.use(async ({ request, set }, next) => {
  const token = request.headers.get('authorization')
  
  if (token) {
    try {
      const user = await verifyToken(token)
      Context.set({ user })
    } catch (error) {
      // Token invalid, but don't block request
      // Route handlers can check if user exists
    }
  }
  
  return next()
})

// Usage in route handlers
router.get('/api/profile', () => {
  const { user, requestId, ip } = Context.get()
  
  if (!user) {
    throw new Error('Authentication required')
  }
  
  return {
    user: { id: user.id, name: user.name },
    requestId,
    ip,
    timestamp: Date.now()
  }
})
```

### Error Handling Middleware
```typescript
// Global error handler
router.use(async ({}, next) => {
  try {
    return await next()
  } catch (error) {
    console.error('Unhandled error:', error)
    
    set.status = 500
    set.content = 'json'
    
    return {
      error: 'Internal Server Error',
      message: process.env.NODE_ENV === 'development' ? error.message : undefined
    }
  }
})

// Async error handling
router.use(async ({ request, set }, next) => {
  try {
    return await next()
  } catch (error) {
    // Different error types
    if (error.type === 'ValidationError') {
      set.status = 400
      return { error: 'Validation failed', details: error.details }
    }
    
    if (error.type === 'UnauthorizedError') {
      set.status = 401
      return { error: 'Unauthorized' }
    }
    
    // Default error
    set.status = 500
    return { error: 'Internal server error' }
  }
})

// Route-specific error handling
router.get('/api/risky',
  async ({ set }) => {
    try {
      const result = await riskyOperation()
      return result
    } catch (error) {
      set.status = 500
      return { error: 'Operation failed', reason: error.message }
    }
  }
)
```

### Conditional Middleware
```typescript
// Conditional middleware based on route
router.use(({ request }, next) => {
  // Only apply to API routes
  if (request.url.startsWith('/api/')) {
    console.log('API request:', request.url)
  }
  
  return next()
})

// Environment-specific middleware
if (process.env.NODE_ENV === 'development') {
  router.use(({ request }, next) => {
    console.log('[DEV]', request.method, request.url)
    return next()
  })
}

// Middleware with conditions
const requireAuth = async ({ request, set }, next) => {
  const publicPaths = ['/api/login', '/api/register', '/api/health']
  
  // Skip auth for public paths
  if (publicPaths.includes(new URL(request.url).pathname)) {
    return next()
  }
  
  const token = request.headers.get('authorization')
  if (!token) {
    set.status = 401
    return { error: 'Authorization required' }
  }
  
  const user = await verifyToken(token)
  Context.set({ user })
  
  return next()
}
```

## Implementation Details

### Middleware Interface
```typescript
type Middleware = (
  context: RouteContext<string>,
  next: () => Promise<void>
) => Promise<any> | any

interface RouteContext<TPath extends string> {
  request: Request
  params: RouteParams<TPath>
  query: Record<string, string>
  body: any
  set: ResponseSetter
}

// Middleware with error handling
type ErrorHandler = (
  error: any,
  context: RouteContext<string>
) => Promise<any> | any
```

### Router Middleware Storage
```typescript
class Router {
  private globalMiddlewares: Middleware[] = []
  private routes: Route[] = []
  private errorHandlers: ErrorHandler[] = []
  
  // Add global middleware
  use(middleware: Middleware): void {
    this.globalMiddlewares.push(middleware)
  }
  
  // Add error handler
  use(errorHandler: ErrorHandler): void
  
  // Route with middleware array
  post<Path extends string>(
    path: Path,
    middlewares: Middleware[],
    handler: RouteHandler<Path>
  ): void {
    this.addRoute('POST', path, handler, middlewares)
  }
  
  private async executeMiddlewareChain(
    context: RouteContext<string>,
    middlewares: Middleware[],
    handler: RouteHandler<string>
  ): Promise<any> {
    let index = 0
    
    const next = async (): Promise<void> => {
      if (index < middlewares.length) {
        const middleware = middlewares[index++]
        return middleware(context, next)
      } else {
        // All middleware executed, call handler
        return handler(context)
      }
    }
    
    try {
      return await next()
    } catch (error) {
      // Handle errors with error handlers
      for (const errorHandler of this.errorHandlers) {
        const result = await errorHandler(error, context)
        if (result !== undefined) {
          return result
        }
      }
      throw error
    }
  }
}
```

### Route Execution with Middleware
```typescript
async function executeRoute(
  request: Request,
  routeMatch: RouteMatch,
  router: Router
): Promise<Response> {
  const context = createRouteContext(request, routeMatch)
  
  // Combine global and route-specific middleware
  const allMiddlewares = [
    ...router.globalMiddlewares,
    ...(routeMatch.route.middlewares || [])
  ]
  
  try {
    const result = await router.executeMiddlewareChain(
      context,
      allMiddlewares,
      routeMatch.route.handler
    )
    
    return buildResponse(result, context.set)
  } catch (error) {
    console.error('Route execution error:', error)
    return new Response('Internal Server Error', { status: 500 })
  }
}
```

### Context-Aware Middleware
```typescript
// Middleware that modifies context
const addRequestId = ({}, next) => {
  Context.init()
  Context.set({
    requestId: generateId(),
    startTime: Date.now()
  })
  
  return next()
}

// Middleware that reads context
const logRequest = async ({ request }, next) => {
  const context = Context.get<{ requestId: string; startTime: number }>()
  
  console.log(`[${context.requestId}] ${request.method} ${request.url}`)
  
  const start = context.startTime
  await next()
  
  const duration = Date.now() - start
  console.log(`[${context.requestId}] Completed in ${duration}ms`)
}

// Middleware that updates context
const setUserContext = async ({ request }, next) => {
  const token = request.headers.get('authorization')
  
  if (token) {
    const user = await verifyToken(token)
    const context = Context.get()
    context.user = user
  }
  
  return next()
}
```

## Testing Strategy

### Middleware Tests
```typescript
describe('Middleware System', () => {
  test('executes global middleware', async () => {
    const router = createRouter()
    let executed = false
    
    router.use(async ({}, next) => {
      executed = true
      await next()
    })
    
    router.get('/test', () => 'test')
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/test'))
    
    expect(executed).toBe(true)
    expect(await response.text()).toBe('test')
  })
  
  test('executes route-specific middleware', async () => {
    const router = createRouter()
    const middlewareOrder: string[] = []
    
    const middleware1 = async ({}, next) => {
      middlewareOrder.push('middleware1')
      await next()
    }
    
    const middleware2 = async ({}, next) => {
      middlewareOrder.push('middleware2')
      await next()
    }
    
    router.get('/test', [middleware1, middleware2], () => {
      middlewareOrder.push('handler')
      return 'result'
    })
    
    const server = createServer({ router })
    await server.fetch(new Request('http://localhost/test'))
    
    expect(middlewareOrder).toEqual(['middleware1', 'middleware2', 'handler'])
  })
  
  test('handles middleware errors', async () => {
    const router = createRouter()
    
    router.use(async ({}, next) => {
      throw new Error('Middleware error')
    })
    
    router.get('/test', () => 'test')
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/test'))
    
    expect(response.status).toBe(500)
  })
})
```

### Context Integration Tests
```typescript
describe('Context Integration', () => {
  test('middleware can set and read context', async () => {
    const router = createRouter()
    
    router.use(async ({}, next) => {
      Context.init()
      Context.set({ test: 'middleware' })
      await next()
    })
    
    router.get('/test', () => {
      const context = Context.get<{ test: string }>()
      return { test: context.test }
    })
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/test'))
    const data = await response.json()
    
    expect(data.test).toBe('middleware')
  })
  
  test('context works across async middleware', async () => {
    const router = createRouter()
    
    router.use(async ({}, next) => {
      Context.init()
      Context.set({ requestId: 'test-123' })
      
      // Async operation
      await new Promise(resolve => setTimeout(resolve, 10))
      
      await next()
    })
    
    router.get('/test', () => {
      const context = Context.get<{ requestId: string }>()
      return { requestId: context.requestId }
    })
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/test'))
    const data = await response.json()
    
    expect(data.requestId).toBe('test-123')
  })
})
```

## Performance Considerations

### Middleware Optimization
- Lazy middleware execution
- Minimal object creation in middleware chain
- Efficient error propagation
- Context access optimization

### Memory Management
- Context objects are request-scoped and garbage collected
- Middleware arrays are reused across requests
- No memory leaks from async operations

## Documentation

### API Reference
- `router.use()` middleware registration
- Route-specific middleware arrays
- Error handler middleware
- Context integration patterns

### Examples
- Authentication middleware
- Logging and monitoring
- CORS handling
- Rate limiting
- Request validation

## Success Criteria

### Functional Requirements
- [ ] Express-compatible middleware API
- [ ] Global middleware support
- [ ] Route-specific middleware chains
- [ ] Error handling middleware
- [ ] Context integration
- [ ] Conditional middleware execution

### Performance Requirements
- [ ] <0.1ms overhead per middleware
- [ ] No memory leaks from middleware chains
- [ ] Efficient error propagation
- [ ] Fast context access

### Compatibility Requirements
- [ ] Express middleware compatibility
- [ ] Async/await support
- [ ] Error handling patterns
- [ ] Context preservation

## Next Steps

This increment establishes the middleware foundation. The next increment (1.2) will focus on wildcard routes and comprehensive error handling to complete the core routing system.