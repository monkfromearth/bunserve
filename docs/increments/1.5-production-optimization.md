# Increment 1.5: Production Optimization

## Overview
This increment focuses on production-ready features including compression, advanced monitoring, health checks, and deployment utilities. These optimizations ensure high performance, reliability, and observability in production environments.

## Objectives
- Implement response compression middleware
- Add comprehensive monitoring and metrics
- Provide health check endpoints
- Add graceful shutdown capabilities
- Include deployment utilities and monitoring

## API Design

### Response Compression
```typescript
import { createRouter, createServer } from 'bunserve'
import { compression } from 'bunserve/middleware'

const router = createRouter()

// Enable compression for all responses
router.use(compression())

// Advanced compression configuration
router.use(compression({
  threshold: 1024,        // Only compress responses larger than 1KB
  level: 6,              // Compression level (1-9, default 6)
  minRatio: 0.8,         // Only compress if ratio is better than this
  filter: (req, res) => {
    // Don't compress images or already compressed content
    const type = res.headers['content-type'] || ''
    return !type.includes('image') && !type.includes('application/zip')
  }
}))

// Brotli compression for supported clients
router.use(compression({
  brotli: {
    enabled: true,
    quality: 6,          // Brotli quality (0-11)
    windowSize: 22        // Brotli window size (10-24)
  },
  gzip: {
    enabled: true,
    level: 6
  }
}))
```

### Health Check Endpoints
```typescript
import { healthCheck } from 'bunserve/health'

// Basic health check
router.get('/health', healthCheck())

// Comprehensive health check with database and external services
router.get('/health', healthCheck({
  checks: {
    database: async () => {
      try {
        await db.query('SELECT 1')
        return { status: 'healthy', latency: 12 }
      } catch (error) {
        return { status: 'unhealthy', error: error.message }
      }
    },
    redis: async () => {
      try {
        const latency = await redis.ping()
        return { status: 'healthy', latency }
      } catch (error) {
        return { status: 'unhealthy', error: error.message }
      }
    },
    externalAPI: async () => {
      try {
        const response = await fetch('https://api.external-service.com/health')
        if (response.ok) {
          return { status: 'healthy' }
        } else {
          return { status: 'degraded', status: response.status }
        }
      } catch (error) {
        return { status: 'unhealthy', error: error.message }
      }
    }
  },
  timeout: 5000, // 5 second timeout for all checks
  onSuccess: ({ set }) => {
    set.status = 200
    return { status: 'healthy', timestamp: new Date().toISOString() }
  },
  onFailure: ({ set }, results) => {
    const unhealthyChecks = Object.entries(results)
      .filter(([, result]) => result.status !== 'healthy')
    
    if (unhealthyChecks.length === 0) {
      set.status = 200
      return { status: 'healthy' }
    } else if (unhealthyChecks.some(([, result]) => result.status === 'unhealthy')) {
      set.status = 503
      return { 
        status: 'unhealthy',
        unhealthy: unhealthyChecks.map(([name, result]) => ({
          name,
          status: result.status,
          error: result.error
        }))
      }
    } else {
      set.status = 200
      return { 
        status: 'degraded',
        issues: unhealthyChecks.map(([name, result]) => ({
          name,
          status: result.status
        }))
      }
    }
  }
}))

// Readiness and liveness probes (Kubernetes)
router.get('/health/live', () => ({ status: 'alive' }))
router.get('/health/ready', healthCheck({
  checks: {
    database: () => db.query('SELECT 1'),
    cache: () => redis.ping()
  }
}))
```

### Metrics and Monitoring
```typescript
import { metrics } from 'bunserve/metrics'

// Enable metrics collection
router.use(metrics())

// Custom metrics
router.use(metrics({
  prefix: 'bunserve_',
  labels: { service: 'my-api' },
  enabled: true,
  collectDefaultMetrics: true,
  customMetrics: {
    user_registrations: new Counter({
      name: 'user_registrations_total',
      help: 'Total number of user registrations',
      labelNames: ['plan']
    }),
    request_duration: new Histogram({
      name: 'request_duration_seconds',
      help: 'Request duration in seconds',
      buckets: [0.1, 0.5, 1, 2, 5]
    })
  }
}))

// Use metrics in routes
router.post('/api/users', async () => {
  const user = await createUser()
  
  // Increment custom metric
  metrics.increment('user_registrations', { plan: user.plan })
  
  return user
})

// Expose metrics endpoint
router.get('/metrics', async () => {
  const metricsData = await metrics.collect()
  return metricsData
})

// Request timing middleware
router.use(async ({ request }, next) => {
  const start = Date.now()
  
  try {
    const result = await next()
    const duration = (Date.now() - start) / 1000
    
    // Record request duration
    metrics.observe('request_duration', duration, {
      method: request.method,
      route: request.url,
      status: '200'
    })
    
    return result
  } catch (error) {
    const duration = (Date.now() - start) / 1000
    metrics.observe('request_duration', duration, {
      method: request.method,
      route: request.url,
      status: '500'
    })
    throw error
  }
})
```

### Graceful Shutdown
```typescript
import { createServer } from 'bunserve'

const router = createRouter()

const server = createServer({
  router,
  shutdown: {
    timeout: 30000, // 30 second graceful shutdown timeout
    drain: true    // Wait for existing connections to finish
  }
})

// Handle shutdown signals
const shutdown = async (signal: string) => {
  console.log(`Received ${signal}, starting graceful shutdown...`)
  
  try {
    await server.shutdown()
    console.log('Graceful shutdown completed')
    process.exit(0)
  } catch (error) {
    console.error('Graceful shutdown failed:', error)
    process.exit(1)
  }
}

process.on('SIGTERM', () => shutdown('SIGTERM'))
process.on('SIGINT', () => shutdown('SIGINT'))

// Health check during shutdown
let isShuttingDown = false

router.get('/health', ({ set }) => {
  if (isShuttingDown) {
    set.status = 503
    return { status: 'shutting_down' }
  }
  return { status: 'healthy' }
})

// Stop accepting new connections during shutdown
process.on('SIGTERM', async () => {
  isShuttingDown = true
  
  // Wait for existing requests to finish
  await new Promise(resolve => setTimeout(resolve, 25000))
  
  await server.close()
  process.exit(0)
})
```

### Rate Limiting and Security
```typescript
import { rateLimit, helmet } from 'bunserve/middleware'

// Advanced rate limiting
router.use(rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: (req) => {
    // Different limits for different users
    const user = getUserFromRequest(req)
    return user?.plan === 'premium' ? 1000 : 100
  },
  skip: (req) => {
    // Skip rate limiting for trusted IPs
    const trustedIPs = ['127.0.0.1', '::1']
    return trustedIPs.includes(req.ip)
  },
  handler: ({ set }) => {
    set.status = 429
    set.content = 'json'
    return {
      error: 'Too many requests',
      retryAfter: '900' // 15 minutes
    }
  },
  store: new RedisStore({    // Use Redis for distributed rate limiting
    host: 'localhost',
    port: 6379
  })
}))

// Security headers for production
router.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
      sandbox: ['allow-same-origin', 'allow-scripts']
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  xssFilter: true,
  referrerPolicy: 'strict-origin-when-cross-origin'
}))
```

### Request/Response Logging
```typescript
import { logger } from 'bunserve/middleware'

// Production logging with structured output
router.use(logger({
  enabled: true,
  format: 'json', // 'json' | 'combined' | 'dev'
  level: 'info',
  customFields: {
    service: 'my-api',
    version: '1.0.0'
  },
  filter: (req) => {
    // Don't log health checks
    return !req.url.startsWith('/health')
  },
  serializers: {
    req: (req) => ({
      method: req.method,
      url: req.url,
      ip: req.ip,
      userAgent: req.headers.get('user-agent'),
      timestamp: new Date().toISOString()
    }),
    res: (res) => ({
      status: res.status,
      contentLength: res.headers['content-length'],
      duration: res.duration
    })
  }
}))

// Error logging with error tracking service
router.use(async ({}, next) => {
  try {
    return await next()
  } catch (error) {
    // Log to error tracking service
    await errorTracker.captureException(error, {
      request: {
        url: request.url,
        method: request.method,
        headers: Object.fromEntries(request.headers.entries()),
        body: request.body
      },
      context: Context.get()
    })
    
    throw error
  }
})
```

### Deployment Utilities
```typescript
import { deployment } from 'bunserve/deployment'

// Deployment info endpoint
router.get('/deployment', deployment.info({
  version: '1.0.0',
  commit: process.env.GIT_COMMIT || 'unknown',
  buildTime: process.env.BUILD_TIME || 'unknown',
  environment: process.env.NODE_ENV || 'development'
}))

// Feature flags
router.use(deployment.featureFlags({
  service: 'feature-flag-service',
  apiKey: process.env.FEATURE_FLAG_API_KEY,
  cacheTTL: 30000, // 30 seconds
  flags: {
    new_ui: { defaultValue: false },
    advanced_search: { defaultValue: true },
    beta_features: { defaultValue: false }
  }
}))

// Usage in routes
router.get('/api/features', () => {
  const flags = Context.get('featureFlags')
  return {
    newUI: flags.new_ui,
    advancedSearch: flags.advanced_search,
    betaFeatures: flags.beta_features
  }
})
```

## Implementation Details

### Compression Middleware
```typescript
interface CompressionOptions {
  threshold?: number
  level?: number
  minRatio?: number
  brotli?: {
    enabled: boolean
    quality?: number
    windowSize?: number
  }
  gzip?: {
    enabled: boolean
    level?: number
  }
  filter?: (req: Request, res: Response) => boolean
}

function compression(options: CompressionOptions = {}): Middleware {
  const config = {
    threshold: 1024,
    level: 6,
    minRatio: 0.8,
    brotli: { enabled: true, quality: 6, windowSize: 22 },
    gzip: { enabled: true, level: 6 },
    ...options
  }
  
  return async ({ request, set }, next) => {
    const result = await next()
    
    // Skip compression for small responses
    const responseSize = JSON.stringify(result).length
    if (responseSize < config.threshold) {
      return result
    }
    
    // Check if client accepts compression
    const acceptEncoding = request.headers.get('accept-encoding') || ''
    
    let compressedResult: Uint8Array | null = null
    let encoding = ''
    
    // Try Brotli first
    if (config.brotli.enabled && acceptEncoding.includes('br')) {
      compressedResult = Bun.compress(result, { level: config.brotli.quality })
      encoding = 'br'
    }
    // Try gzip
    else if (config.gzip.enabled && acceptEncoding.includes('gzip')) {
      compressedResult = Bun.compress(result, { gzip: true, level: config.gzip.level })
      encoding = 'gzip'
    }
    
    // Use compressed response if beneficial
    if (compressedResult && compressedResult.length / responseSize < config.minRatio) {
      set.headers['Content-Encoding'] = encoding
      set.headers['Content-Length'] = String(compressedResult.length)
      return compressedResult
    }
    
    return result
  }
}
```

### Metrics Collection
```typescript
class MetricsCollector {
  private counters: Map<string, Counter> = new Map()
  private histograms: Map<string, Histogram> = new Map()
  private gauges: Map<string, Gauge> = new Map()
  
  counter(name: string, help: string, labels?: string[]): Counter {
    if (!this.counters.has(name)) {
      this.counters.set(name, new Counter(name, help, labels))
    }
    return this.counters.get(name)!
  }
  
  histogram(name: string, help: string, buckets?: number[]): Histogram {
    if (!this.histograms.has(name)) {
      this.histograms.set(name, new Histogram(name, help, buckets))
    }
    return this.histograms.get(name)!
  }
  
  async collect(): Promise<string> {
    let output = ''
    
    for (const counter of this.counters.values()) {
      output += await counter.collect() + '\n'
    }
    
    for (const histogram of this.histograms.values()) {
      output += await histogram.collect() + '\n'
    }
    
    for (const gauge of this.gauges.values()) {
      output += await gauge.collect() + '\n'
    }
    
    return output
  }
}

// Prometheus metrics types
class Counter {
  constructor(
    private name: string,
    private help: string,
    private labelNames: string[] = []
  ) {}
  
  inc(labels: Record<string, string> = {}): void {
    // Increment counter
  }
  
  async collect(): Promise<string> {
    return `# HELP ${this.name} ${this.help}\n# TYPE ${this.name} counter\n${this.name} 0`
  }
}
```

### Graceful Shutdown Handler
```typescript
class GracefulShutdown {
  private isShuttingDown = false
  private activeConnections = new Set<Connection>()
  
  constructor(private server: any, private timeout: number = 30000) {}
  
  async shutdown(): Promise<void> {
    if (this.isShuttingDown) return
    
    this.isShuttingDown = true
    console.log('Starting graceful shutdown...')
    
    // Stop accepting new connections
    this.server.stop()
    
    // Wait for active connections to finish
    if (this.activeConnections.size > 0) {
      console.log(`Waiting for ${this.activeConnections.size} active connections...`)
      
      await Promise.race([
        this.waitForConnections(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Shutdown timeout')), this.timeout)
        )
      ])
    }
    
    console.log('Graceful shutdown completed')
  }
  
  private waitForConnections(): Promise<void> {
    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        if (this.activeConnections.size === 0) {
          clearInterval(checkInterval)
          resolve()
        }
      }, 100)
    })
  }
  
  trackConnection(connection: Connection): void {
    this.activeConnections.add(connection)
    connection.onClose(() => {
      this.activeConnections.delete(connection)
    })
  }
}
```

## Testing Strategy

### Production Feature Tests
```typescript
describe('Production Optimization', () => {
  test('compresses responses when supported', async () => {
    const router = createRouter()
    router.use(compression())
    router.get('/large-data', () => ({ data: 'x'.repeat(2048) }))
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/large-data', {
      headers: { 'Accept-Encoding': 'gzip' }
    }))
    
    expect(response.headers.get('Content-Encoding')).toBe('gzip')
  })
  
  test('health check reports service status', async () => {
    const router = createRouter()
    router.get('/health', healthCheck({
      checks: {
        test: () => ({ status: 'healthy' })
      }
    }))
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/health'))
    
    expect(response.status).toBe(200)
    const data = await response.json()
    expect(data.status).toBe('healthy')
  })
  
  test('graceful shutdown works', async () => {
    const router = createRouter()
    const server = createServer({ 
      router,
      shutdown: { timeout: 1000 }
    })
    
    await server.shutdown()
    // Verify server is shut down
    expect(() => server.listen()).toThrow()
  })
})
```

## Performance Considerations

### Compression Optimization
- Only compress responses above threshold size
- Choose best compression algorithm based on client support
- Cache compression results for static content
- Minimal CPU overhead for compression

### Metrics Overhead
- Efficient metric collection with minimal overhead
- Asynchronous metric reporting
- Sampling for high-frequency metrics
- Memory-efficient metric storage

### Shutdown Reliability
- Track active connections accurately
- Timeout to prevent indefinite shutdown
- Preserve in-flight requests
- Clean resource cleanup

## Documentation

### Production Guide
- Compression configuration
- Health check setup
- Metrics and monitoring
- Graceful shutdown
- Deployment strategies

### Security Best Practices
- Rate limiting configuration
- Security headers
- Input validation
- Error handling in production

## Success Criteria

### Functional Requirements
- [ ] Response compression middleware
- [ ] Health check endpoints
- [ ] Metrics collection system
- [ ] Graceful shutdown
- [ ] Production logging
- [ ] Rate limiting
- [ ] Deployment utilities

### Performance Requirements
- [ ] <10ms compression overhead
- [ ] <1ms metrics collection overhead
- [ ] <5s graceful shutdown timeout
- [ ] Efficient memory usage

### Reliability Requirements
- [ ] 99.9% uptime during deployment
- [ ] Zero lost requests during shutdown
- [ ] Comprehensive health checks
- [ ] Error tracking and alerting

## Next Steps

This increment completes the core production features. Future enhancements could include advanced monitoring, A/B testing, advanced caching strategies, and cloud-native deployment utilities.