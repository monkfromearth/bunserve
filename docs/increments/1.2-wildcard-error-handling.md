# Increment 1.2: Wildcard Routes & Error Handling

## Overview
This increment implements wildcard route support and comprehensive error handling systems. Wildcard routes enable flexible routing patterns (like `/api/admin/*`), while the error handling system provides both route-specific and global error management with proper HTTP status codes.

## Objectives
- Implement wildcard route matching (`/api/admin/*`, `/files/**`)
- Add route-specific error handling
- Provide global error handlers
- Support custom error types and formatting
- Enable 404/500 error pages

## API Design

### Wildcard Routes
```typescript
import { createRouter, createServer } from 'bunserve'

const router = createRouter()

// Single wildcard - matches one segment
router.get('/api/admin/*', ({ params }) => {
  // params['*'] contains the wildcard segment
  const resource = params['*'] // 'users', 'settings', etc.
  return { 
    admin: true, 
    resource,
    data: getAdminData(resource) 
  }
})

// Multiple wildcards
router.get('/api/v*/users/*', ({ params }) => {
  // params['0'] = '1', '2', etc. (version)
  // params['1'] = 'list', '123', etc. (resource)
  return {
    version: params['0'],
    resource: params['1']
  }
})

// Wildcard with middleware
router.get('/dashboard/*', 
  [requireAuth, requireAdmin],
  ({ params }) => {
    const page = params['*'] // 'overview', 'analytics', etc.
    return getDashboardPage(page)
  }
)

// File serving with wildcard
router.get('/static/*', ({ params, set }) => {
  const filename = params['*'] // 'css/style.css', 'js/app.js', etc.
  const filePath = `./public/${filename}`
  
  try {
    const file = Bun.file(filePath)
    if (!await file.exists()) {
      set.status = 404
      return { error: 'File not found' }
    }
    
    set.headers['Content-Type'] = getMimeType(filename)
    return file
  } catch (error) {
    set.status = 500
    return { error: 'Server error' }
  }
})
```

### Advanced Wildcard Patterns
```typescript
// Catch-all route (must be last)
router.all('*', ({ request, set }) => {
  set.status = 404
  return { 
    error: 'Not Found',
    path: new URL(request.url).pathname,
    method: request.method
  }
})

// API versioning with wildcards
router.get('/api/v1/*', apiV1Handler)
router.get('/api/v2/*', apiV2Handler)

// Nested wildcards
router.get('/users/*/posts/*/comments/*', ({ params }) => {
  return {
    userId: params['0'],
    postId: params['1'], 
    commentId: params['2']
  }
})

// Wildcard with optional parameters
router.get('/search/:query?/*', ({ params }) => {
  return {
    query: params.query,
    filters: params['*'] // 'category/tech', 'date/2024', etc.
  }
})
```

### Route-Specific Error Handling
```typescript
// Try-catch in route handlers
router.get('/api/users/:id', async ({ params, set }) => {
  try {
    const user = await getUserById(params.id)
    
    if (!user) {
      set.status = 404
      return { error: 'User not found' }
    }
    
    return user
  } catch (error) {
    set.status = 500
    set.content = 'json'
    return { 
      error: 'Database error',
      message: process.env.NODE_ENV === 'development' ? error.message : undefined
    }
  }
})

// Custom error types
class ValidationError extends Error {
  type = 'ValidationError'
  constructor(message: string, public details?: any) {
    super(message)
  }
}

class UnauthorizedError extends Error {
  type = 'UnauthorizedError'
  constructor(message: string = 'Unauthorized') {
    super(message)
  }
}

router.post('/api/users', async ({ body, set }) => {
  if (!body.email || !body.password) {
    set.status = 400
    throw new ValidationError('Email and password required', {
      missing: ['email', 'password'].filter(field => !body[field])
    })
  }
  
  if (!isValidEmail(body.email)) {
    set.status = 400
    throw new ValidationError('Invalid email format')
  }
  
  try {
    const user = await createUser(body)
    set.status = 201
    return user
  } catch (error) {
    if (error.code === 'DUPLICATE_EMAIL') {
      set.status = 409
      throw new ValidationError('Email already exists')
    }
    throw error
  }
})
```

### Global Error Handlers
```typescript
// Error handling middleware (must be registered first)
router.use(async ({}, next) => {
  try {
    return await next()
  } catch (error) {
    console.error('Global error handler caught:', error)
    
    // Handle different error types
    switch (error.type) {
      case 'ValidationError':
        return {
          error: 'Validation failed',
          details: error.details,
          status: 400
        }
        
      case 'UnauthorizedError':
        return {
          error: error.message,
          status: 401
        }
        
      case 'NotFoundError':
        return {
          error: 'Resource not found',
          status: 404
        }
        
      default:
        return {
          error: 'Internal server error',
          status: 500,
          message: process.env.NODE_ENV === 'development' ? error.message : undefined
        }
    }
  }
})

// Async error handler
router.use(async ({}, next) => {
  try {
    return await next()
  } catch (error) {
    // Log error with context
    const context = Context.get<{ requestId: string }>()
    console.error(`[${context.requestId}] Error:`, error)
    
    // Return formatted error response
    return {
      error: 'An error occurred',
      requestId: context.requestId,
      timestamp: new Date().toISOString()
    }
  }
})

// Development error handler
if (process.env.NODE_ENV === 'development') {
  router.use(async ({}, next) => {
    try {
      return await next()
    } catch (error) {
      return {
        error: error.message,
        stack: error.stack,
        type: error.constructor.name,
        timestamp: new Date().toISOString()
      }
    }
  })
}
```

### 404 and Error Pages
```typescript
// Custom 404 handler
router.use(({ request, set }, next) => {
  // Try to handle the request
  const result = await next()
  
  // If no route matched and no response yet
  if (!result && !set.headers['content-type']) {
    set.status = 404
    set.content = 'json'
    
    return {
      error: 'Not Found',
      path: new URL(request.url).pathname,
      method: request.method,
      timestamp: new Date().toISOString()
    }
  }
  
  return result
})

// HTML error pages
router.get('/404', ({ set }) => {
  set.status = 404
  set.content = 'html'
  
  return `
    <!DOCTYPE html>
    <html>
      <head>
        <title>404 - Not Found</title>
        <style>
          body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
          h1 { color: #e74c3c; }
        </style>
      </head>
      <body>
        <h1>404 - Page Not Found</h1>
        <p>The page you're looking for doesn't exist.</p>
        <a href="/">Go Home</a>
      </body>
    </html>
  `
})

router.get('/500', ({ set }) => {
  set.status = 500
  set.content = 'html'
  
  return `
    <!DOCTYPE html>
    <html>
      <head>
        <title>500 - Server Error</title>
        <style>
          body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
          h1 { color: #e74c3c; }
        </style>
      </head>
      <body>
        <h1>500 - Server Error</h1>
        <p>Something went wrong on our end. Please try again later.</p>
        <a href="/">Go Home</a>
      </body>
    </html>
  `
})
```

### Error Context Integration
```typescript
// Error handler with context
router.use(async ({}, next) => {
  try {
    return await next()
  } catch (error) {
    const context = Context.get<{
      requestId: string;
      user?: any;
      startTime: number;
    }>()
    
    // Log error with full context
    console.error(`[${context.requestId}] Error:`, {
      error: error.message,
      stack: error.stack,
      user: context.user?.id,
      path: context.request?.url,
      duration: Date.now() - context.startTime
    })
    
    // Return error with context
    return {
      error: 'Internal server error',
      requestId: context.requestId,
      timestamp: new Date().toISOString()
    }
  }
})

// Route with context-aware error handling
router.get('/api/sensitive', async () => {
  const context = Context.get<{ user: any }>()
  
  if (!context.user) {
    throw new UnauthorizedError('Authentication required')
  }
  
  if (!context.user.permissions.includes('sensitive_access')) {
    throw new ForbiddenError('Insufficient permissions')
  }
  
  return getSensitiveData()
})
```

## Implementation Details

### Wildcard Route Parsing
```typescript
// Enhanced route pattern parser
function parseRoutePattern(path: string): {
  pattern: RegExp
  paramNames: string[]
  hasWildcard: boolean
} {
  const paramNames: string[] = []
  let patternStr = path
  let hasWildcard = false
  
  // Handle wildcards
  if (path.includes('*')) {
    hasWildcard = true
    let wildcardIndex = 0
    
    // Replace each * with a numbered capture group
    patternStr = patternStr.replace(/\*/g, () => {
      const paramName = String(wildcardIndex++)
      paramNames.push(paramName)
      return '(.+?)'
    })
  }
  
  // Handle regular parameters
  patternStr = patternStr.replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName)
    return '([^/]+)'
  })
  
  // Handle optional parameters
  patternStr = patternStr.replace(/\/:(\w+)\?/g, '(?:\/([^/]+))?')
  
  return {
    pattern: new RegExp(`^${patternStr}$`),
    paramNames,
    hasWildcard
  }
}
```

### Wildcard Parameter Extraction
```typescript
// Extract parameters including wildcards
function extractWildcardParams(
  paramNames: string[],
  match: RegExpMatchArray
): Record<string, string> {
  const params: Record<string, string> = {}
  
  for (let i = 0; i < paramNames.length; i++) {
    const paramName = paramNames[i]
    const paramValue = match[i + 1]
    
    if (paramValue !== undefined) {
      params[paramName] = paramValue
    }
  }
  
  return params
}

// Route matching with wildcard support
class Router {
  private routes: Route[] = []
  private wildcardRoutes: Route[] = []
  
  addRoute(method: string, path: string, handler: any, middlewares: any[] = []) {
    const { pattern, paramNames, hasWildcard } = parseRoutePattern(path)
    const route = {
      method,
      path,
      handler,
      middlewares,
      pattern,
      paramNames,
      hasWildcard
    }
    
    if (hasWildcard) {
      // Add wildcard routes to separate array for priority handling
      this.wildcardRoutes.push(route)
    } else {
      this.routes.push(route)
    }
  }
  
  find(method: string, pathname: string): RouteMatch | null {
    // Try exact routes first
    for (const route of this.routes) {
      if (route.method !== method) continue
      
      const match = route.pattern.exec(pathname)
      if (match) {
        const params = extractParams(route.paramNames, match)
        return { route, params }
      }
    }
    
    // Try wildcard routes
    for (const route of this.wildcardRoutes) {
      if (route.method !== method) continue
      
      const match = route.pattern.exec(pathname)
      if (match) {
        const params = extractWildcardParams(route.paramNames, match)
        return { route, params }
      }
    }
    
    return null
  }
}
```

### Error Handling System
```typescript
// Error handling middleware
class ErrorHandler {
  private handlers: ErrorHandlerFunction[] = []
  
  use(handler: ErrorHandlerFunction): void {
    this.handlers.push(handler)
  }
  
  async handleError(error: any, context: RouteContext<string>): Promise<any> {
    for (const handler of this.handlers) {
      try {
        const result = await handler(error, context)
        if (result !== undefined) {
          return result
        }
      } catch (handlerError) {
        console.error('Error handler itself failed:', handlerError)
      }
    }
    
    // Default error response
    return {
      error: 'Internal Server Error',
      status: 500
    }
  }
}

// Error handler function type
type ErrorHandlerFunction = (
  error: any,
  context: RouteContext<string>
) => Promise<any> | any

// Built-in error handlers
const defaultErrorHandlers = {
  validation: (error: ValidationError) => ({
    error: 'Validation failed',
    details: error.details,
    status: 400
  }),
  
  unauthorized: (error: UnauthorizedError) => ({
    error: error.message,
    status: 401
  }),
  
  notFound: (error: NotFoundError) => ({
    error: 'Resource not found',
    status: 404
  }),
  
  default: (error: Error) => ({
    error: 'Internal server error',
    status: 500,
    message: process.env.NODE_ENV === 'development' ? error.message : undefined
  })
}
```

### Route Execution with Error Handling
```typescript
async function executeRouteWithErrors(
  request: Request,
  router: Router,
  errorHandler: ErrorHandler
): Promise<Response> {
  try {
    const url = new URL(request.url)
    const routeMatch = router.find(request.method, url.pathname)
    
    if (!routeMatch) {
      // No route found - return 404
      return new Response(JSON.stringify({
        error: 'Not Found',
        path: url.pathname,
        method: request.method
      }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    const context = createRouteContext(request, routeMatch)
    
    try {
      const result = await router.executeMiddlewareChain(
        context,
        [...router.globalMiddlewares, ...(routeMatch.route.middlewares || [])],
        routeMatch.route.handler
      )
      
      return buildResponse(result, context.set)
    } catch (error) {
      // Handle route execution errors
      const errorResult = await errorHandler.handleError(error, context)
      
      // Apply status code from error result
      if (errorResult.status) {
        context.set.status = errorResult.status
      }
      
      return buildResponse(errorResult, context.set)
    }
  } catch (error) {
    // Handle system-level errors
    console.error('System error:', error)
    return new Response('Internal Server Error', { status: 500 })
  }
}
```

## Testing Strategy

### Wildcard Route Tests
```typescript
describe('Wildcard Routes', () => {
  test('matches single wildcard', () => {
    const router = createRouter()
    router.get('/api/*', ({ params }) => ({ resource: params['*'] }))
    
    const match = router.find('GET', '/api/users')
    expect(match).toBeDefined()
    expect(match?.params['*']).toBe('users')
  })
  
  test('matches multiple wildcards', () => {
    const router = createRouter()
    router.get('/api/*/users/*', ({ params }) => ({
      version: params['0'],
      userId: params['1']
    }))
    
    const match = router.find('GET', '/api/v1/users/123')
    expect(match?.params).toEqual({
      '0': 'v1',
      '1': '123'
    })
  })
  
  test('prioritizes exact routes over wildcards', () => {
    const router = createRouter()
    
    // Exact route
    router.get('/api/users', () => 'exact')
    // Wildcard route
    router.get('/api/*', () => 'wildcard')
    
    const match = router.find('GET', '/api/users')
    expect(match?.route.handler()).toBe('exact')
  })
})
```

### Error Handling Tests
```typescript
describe('Error Handling', () => {
  test('handles validation errors', async () => {
    const router = createRouter()
    
    router.use(async ({}, next) => {
      try {
        return await next()
      } catch (error) {
        if (error.type === 'ValidationError') {
          return { error: error.message, status: 400 }
        }
        throw error
      }
    })
    
    router.get('/test', () => {
      throw new ValidationError('Invalid input')
    })
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/test'))
    
    expect(response.status).toBe(400)
    const data = await response.json()
    expect(data.error).toBe('Invalid input')
  })
  
  test('handles 404 for unmatched routes', async () => {
    const router = createRouter()
    router.get('/existing', () => 'exists')
    
    const server = createServer({ router })
    const response = await server.fetch(new Request('http://localhost/nonexistent'))
    
    expect(response.status).toBe(404)
  })
})
```

## Performance Considerations

### Wildcard Route Optimization
- Separate wildcard routes from exact routes for priority handling
- Efficient regex pattern compilation
- Minimal parameter extraction overhead
- Route caching for frequently accessed patterns

### Error Handling Optimization
- Fast error type detection
- Minimal object creation during error handling
- Efficient error propagation
- Context preservation during errors

## Documentation

### API Reference
- Wildcard route patterns (`*`, `**`)
- Error handler middleware
- Custom error types
- 404 handling strategies

### Examples
- API versioning with wildcards
- File serving with wildcards
- Custom error pages
- Error logging and monitoring
- Development vs production error handling

## Success Criteria

### Functional Requirements
- [ ] Wildcard route support (`/api/admin/*`)
- [ ] Multiple wildcard patterns
- [ ] Route priority (exact > wildcard)
- [ ] Global error handlers
- [ ] Route-specific error handling
- [ ] Custom error types
- [ ] 404 error pages

### Performance Requirements
- [ ] <0.05ms wildcard route matching
- [ ] Minimal overhead for exact routes
- [ ] Fast error propagation
- [ ] Efficient memory usage

### Type Safety Requirements
- [ ] Wildcard parameter type inference
- [ ] Error type safety
- [ ] Context integration types
- [ ] Route handler error types

## Next Steps

This increment completes the core routing and error handling foundation. The next increment (1.3) will focus on development server improvements and CLI tools to enhance developer productivity.